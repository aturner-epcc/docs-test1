{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ARCHER2 User Documentation Warning The ARCHER2 Service is not yet available. This documentation is in development. ARCHER2 is due to commence operation in 2020, replacing the current service ARCHER. For more information on ARCHER, please visit the ARCHER web site . ARCHER2 is the next generation UK National Supercomputing Service. You can find more information on the service and the research it supports on the ARCHER2 website . The ARCHER2 Service is a world class advanced computing resource for UK researchers. ARCHER2 is provided by UKRI , EPCC , Cray (an HPE company) and the University of Edinburgh . What the documentation covers This is the documentation for the ARCHER2 service and includes: Quick Start Guide The ARCHER2 quick start guide provides the minimum information for new users or users transferring from ARCHER. user-guide/ Covers all aspects of use of the ARCHER2 supercomputing service. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of ARCHER2, and more advanced technical topics. research-software/ Information on each of the centrally-installed research software packages. software-libraries/ Information on the centrally-installed software libraries. Most libraries work as expected so no additional notes are required however a small number require specific documentation data-tools/ Information on data analysis tools and other useful utilities. essentials/ This section provides information and links on essential skills required to use ARCHER2 efficiently: e.g. using Linux command line, accessing help and documentation. Contributing to the documentation The source for this documentation is publicly available in the ARCHER2 documentation Github repository so that anyone can contribute to improve the documentation for the service. Contributions can be in the form of improvements or additions to the content and/or addition of Issues providing suggestions for how it can be improved. Full details of how to contribute can be found in the README.rst file of the repository. Credits This documentation draws on the Cirrus Tier-2 HPC Documentation , Sheffield Iceberg Documentation and the ARCHER National Supercomputing Service Documentation .","title":"Documentation overview"},{"location":"#archer2-user-documentation","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. ARCHER2 is due to commence operation in 2020, replacing the current service ARCHER. For more information on ARCHER, please visit the ARCHER web site . ARCHER2 is the next generation UK National Supercomputing Service. You can find more information on the service and the research it supports on the ARCHER2 website . The ARCHER2 Service is a world class advanced computing resource for UK researchers. ARCHER2 is provided by UKRI , EPCC , Cray (an HPE company) and the University of Edinburgh .","title":"ARCHER2 User Documentation"},{"location":"#what-the-documentation-covers","text":"This is the documentation for the ARCHER2 service and includes: Quick Start Guide The ARCHER2 quick start guide provides the minimum information for new users or users transferring from ARCHER. user-guide/ Covers all aspects of use of the ARCHER2 supercomputing service. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of ARCHER2, and more advanced technical topics. research-software/ Information on each of the centrally-installed research software packages. software-libraries/ Information on the centrally-installed software libraries. Most libraries work as expected so no additional notes are required however a small number require specific documentation data-tools/ Information on data analysis tools and other useful utilities. essentials/ This section provides information and links on essential skills required to use ARCHER2 efficiently: e.g. using Linux command line, accessing help and documentation.","title":"What the documentation covers"},{"location":"#contributing-to-the-documentation","text":"The source for this documentation is publicly available in the ARCHER2 documentation Github repository so that anyone can contribute to improve the documentation for the service. Contributions can be in the form of improvements or additions to the content and/or addition of Issues providing suggestions for how it can be improved. Full details of how to contribute can be found in the README.rst file of the repository.","title":"Contributing to the documentation"},{"location":"#credits","text":"This documentation draws on the Cirrus Tier-2 HPC Documentation , Sheffield Iceberg Documentation and the ARCHER National Supercomputing Service Documentation .","title":"Credits"},{"location":"data-tools/","text":"Overview Warning The ARCHER2 Service is not yet available. This documentation is in development. This section provides information on each of the centrally-installed data analysis tools: versions available, how to get access, good practice for getting best performance, links to associated training and webinars, links to associated technical reports (eCSE final reports, white papers), links to instruction manuals and further information. Tools covered: Anaconda Climate Data Operators (CDO) CFD General Notation System (CGNS) NCAR Command Language (NCL) NetCDF Operators (NCO) Paraview PLUMED PyTorch R TensorFlow VMD VASP Transition State Tools (VTST)","title":"Index"},{"location":"data-tools/#overview","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. This section provides information on each of the centrally-installed data analysis tools: versions available, how to get access, good practice for getting best performance, links to associated training and webinars, links to associated technical reports (eCSE final reports, white papers), links to instruction manuals and further information. Tools covered: Anaconda Climate Data Operators (CDO) CFD General Notation System (CGNS) NCAR Command Language (NCL) NetCDF Operators (NCO) Paraview PLUMED PyTorch R TensorFlow VMD VASP Transition State Tools (VTST)","title":"Overview"},{"location":"essentials/","text":"Overview Warning The ARCHER2 Service is not yet available. This documentation is in development. This section provides information and links on essential skills required to use ARCHER2 efficiently: e.g. using Linux command line, accessing help and documentation.","title":"Overview"},{"location":"essentials/#overview","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. This section provides information and links on essential skills required to use ARCHER2 efficiently: e.g. using Linux command line, accessing help and documentation.","title":"Overview"},{"location":"quick-start/","text":"Overview Warning The ARCHER2 Service is not yet available. This documentation is in development. The ARCHER2 quick start guide provides the minimum information for new users or users transferring from ARCHER. There are two versions available: quickstart-users : Covers the basics of ARCHER2 useful for all users, including: applying for an account, logging in and transferring data, accessing software and running jobs. quickstart-developers : Covers additional topics around compiling your own programs on ARCHER2, debugging and profiling.","title":"Overview"},{"location":"quick-start/#overview","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. The ARCHER2 quick start guide provides the minimum information for new users or users transferring from ARCHER. There are two versions available: quickstart-users : Covers the basics of ARCHER2 useful for all users, including: applying for an account, logging in and transferring data, accessing software and running jobs. quickstart-developers : Covers additional topics around compiling your own programs on ARCHER2, debugging and profiling.","title":"Overview"},{"location":"quick-start/quickstart-developers/","text":"Quickstart for developers Warning The ARCHER2 Service is not yet available. This documentation is in development. This guide aims to quickly enable developers to work on ARCHER2. It assumes that you are familiar with the material in quickstart-users . Compiler wrappers When compiling code on ARCHER2, you should make use of the Cray compiler wrappers. These ensure that the correct libraries and headers (for example, MPI or Cray LibSci) will be used during the compilation and linking stages. These wrappers should be accessed by providing the following compiler names: Language Wrapper name C cc C++ CC Fortran ftn This means that you should use the wrapper names whether on the command line, in build scripts, or in configure options. It could be helpful to set some or all of the following environment variables before running a build to ensure that the build tool is aware of the wrappers: export CC=cc export CXX=CC export FC=ftn export F77=ftn export F90=ftn man pages are available for each wrapper. You can also see the full set of compiler and linker options being used by passing the -craype-verbose option to the wrapper when using it. Programming environments On login to ARCHER2, the PrgEnv-cray module will be loaded, as will a cce module. The latter makes available Cray's compilers from the Cray Compiling Environment (CCE), while the former provides the correct wrappers and support to use them. The GNU Compiler Collection (GCC) is also available. To make use of any Programming Environment, simply swap to the correct PrgEnv module. After doing so the compiler wrappers ( cc , CC and ftn ) will correctly call the compilers from the new suite. The default version of the corresponding compiler suite will also be loaded, but you may swap to another available version if you wish. The following table summarises the suites and associated programming environments. Suite name Module Programming environment module CCE cce PrgEnv-cray GCC gcc PrgEnv-gnu As an example, after logging in you may wish to use GCC as your compiler suite. Running module swap PrgEnv-cray PrgEnv-gnu will unload the Cray environment and replace it with the GNU environment. It will also unload the cce module and load the default version of the gcc module; at the time of writing, this is GCC 9.3.0. If you need to use a different version of GCC, for example 8.1.0, you would follow up with module swap gcc gcc/8.1.0 . At this point you may invoke the compiler wrappers and they will correctly use Cray's libraries and tools in conjunction with GCC 8.1.0. When choosing the programming environment, a big factor will likely be which compilers you have previously used for your code's development. The Cray Fortran compiler is similar to the compiler you may be familiar with from ARCHER, while the Cray C and C++ compilers provided on ARCHER2 are new versions that are now derived from Clang. The GCC suite provides gcc and gfortran. Note Unlike ARCHER, the Intel compilers are not available on ARCHER2. Note We will add information on the AOCC compilers when they become available. Useful compiler options The compiler options you use will depend on both the software you are building and also on the current stage of development. The following flags should be a good starting point for reasonable performance: Compilers Optimisation flags Cray C/C++ -O2 -funroll-loops -ffast-math Cray Fortran Default options GCC -O2 -ftree-vectorize -funroll-loops -ffast-math When you are happy with your code's performance you may wish to enable more aggressive optimisations; in this case you could start using the following flags. Please note, however, that these optimisations may lead to deviations from IEEE/ISO specifications. If your code relies on strict adherence then these flags may lead to it producing incorrect output. Compilers Optimisation flags Cray C/C++ -Ofast -funroll-loops Cray Fortran -O3 -hfp3 GCC -Ofast -funroll-loops Vectorisation is enabled by the Cray Fortran compiler at -O1 and above, by Cray C and C++ at -O2 and above or when using -ftree-vectorize , and by the GCC compilers at -O3 and above or when using -ftree-vectorize . You may wish to promote default real and integer types in Fortran codes from 4 to 8 bytes. In this case, the following flags may be used: Compiler Fortran real and integer promotion flags Cray Fortran -s real64 -s integer64 gfortran -freal-4-real-8 -finteger-4-integer-8 More documentation on the compilers is available through man . The pages to read are accessed as follow: Compiler suite C C++ Fortran Cray man craycc man crayCC man crayftn GNU man gcc man g++ man gfortran Note We will add information on the AOCC compilers when they become available. Linking on ARCHER2 Executables on ARCHER2 link dynamically, and the Cray Programming Environment does not currently support static linking. This is in contrast to ARCHER where the default was to build statically. Using RPATHs to link The default behaviour of a dynamically linked executable will be to allow the linker to provide the libraries it needs at runtime by searching the paths in the LD_LIBRARY_PATH environment variable. This is flexible in that it allows an executable to use newly installed library versions without rebuilding, but in some cases you may prefer to bake the paths to specific libraries into the executable, keeping them constant. While the libraries are still dynamically loaded at run time, from the end user's point of view the resulting behaviour will be similar to that of a statically compiled executable in that they will not need to concern themselves with ensuring the linker will be able to find the libraries. This is achieved by providing RPATHs to the compiler as options. To set the compiler wrappers to do this, you can set the following environment variable: export CRAY_ADD_RPATH=yes You can also provide RPATHs directly to the compilers using the -Wl,-rpath=<path-to-directory> flag, where the provided path is to the directory containing the libraries which are themselves typically specified with flags of the type -l<library-name> . Debugging tools The following debugging tools are available on ARCHER2: gdb4hpc is a command-line tool working similarly to gdb \\<https://www.gnu.org/software/gdb/> that allows users to debug parallel programs. It can launch parallel programs or attach to ones already running and allows the user to step through the execution to identify the causes of any unexpected behaviour. Available via module load gdb4hpc . valgrind4hpc is a parallel memory debugging tool that aids in detection of memory leaks and errors in parallel applications. It aggregates like errors across processes and threads to simplify debugging of parallel appliciations. Available via module load valgrind4hpc . STAT , the Stack Trace Analysis Tool, generates merged stack traces for parallel applications. It also provides visualisation tools. Available via module load cray-stat . * ATP , Abnormal Termiation Processing, offers scalable core file and backtrace analysis when parallel programs crash. Output can be viewed with STAT. Available via module load atp . To get started debugging on ARCHER2, you might like to use gdb4hpc. You should first of all compile your code using the -g flag to enable debugging symbols. Once compiled, load the gdb4hpc module and start it: module load gdb4hpc gdb4hpc Once inside gdb4hpc, you can start your program's execution with the launch command: dbg all> launch $my_prog{128} ./prog In this example, a job called my_prog will be launched to run the executable file prog over 128 cores on a compute node. If you run squeue in another terminal you will be able to see it running. Inside gdb4hpc you may then step through the code's execution, continue to breakpoints that you set with break , print the values of variables at these points, and perform a backtrace on the stack if the program crashes. Debugging jobs will end when you exit gdb4hpc, or you can end them yourself by running, in this example, release $my_prog . For more information on debugging parallel codes, see the documentation at ARCHER2 User and Best Practice Guide - Debugging <../user-guide/debug> . Note We will add more information on using the debugging tools once the ARCHER2 system is available. Profiling tools Profiling on ARCHER2 is provided through the Cray Performance Measurement and Analysis Tools (CrayPAT). This has a number of different components: CrayPAT the full-featured program analysis tool set. CrayPAT consists of pat_build, the utility used to instrument programs, the CrayPat run time environment, which collects the specified performance data during program execution, and pat_report, the first-level data analysis tool, used to produce text reports or export data for more sophisticated analysis CrayPAT-lite a simplified and easy-to-use version of CrayPAT that provides basic performance analysis information automatically, with a minimum of user interaction. Reveal the next-generation integrated performance analysis and code optimization tool, which enables the user to correlate performance data captured during program execution directly to the original source, and identify opportunities for further optimization. Cray PAPI components, which are support packages for those who want to access performance counters. Cray Apprentice2 the second-level data analysis tool, used to visualize, manipulate, explore, and compare sets of program performance data in a GUI environment. The above tools are made available for use by firstly loading the perftools-base module followed by either perftools (for CrayPAT, Reveal and Apprentice2) or one of the perftools-lite modules. The simplest way to get started profiling your code is with CrayPAT-lite. For example, to sample a run of a code you would load the perftools-base and perftools-lite modules, and then compile (you will receive a message that the executable is being instrumented). Performing a batch run as usual with this executable will produce a directory such as my_prog+74653-2s which can be passed to pat_report to view the results. In this example, pat_report -O calltree+src my_prog+74653-2s will produce a report containing the call tree. You can view available report keywords to be provided to the -O option by running pat_report -O -h . The available perftools-lite modules are: perftools-lite , instrumenting a basic sampling experiment. perftools-lite-events , instrumenting a tracing experiment. perftools-lite-gpu , instrumenting OpenACC and OpenMP 4 use of GPUs. perftools-lite-hbm , instrumenting for memory bandwidth usage. perftools-lite-loops , instrumenting a loop work estimate experiment. For more information on profiling parallel codes, see the documentation at ARCHER2 User and Best Practice Guide - Profiling <../user-guide/profile> . Note We will add more information on using the profiling tools once the ARCHER2 system is available. Useful Links Links to other documentation you may find useful: ARCHER2 User and Best Practice Guide <../user-guide/overview> - Covers all aspects of use of the ARCHER2 service. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of ARCHER2, and more advanced technical topics. Cray Programming Environment User Guide Cray Performance Measurement and Analysis Tools User Guide","title":"Quickstart for developers"},{"location":"quick-start/quickstart-developers/#quickstart-for-developers","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. This guide aims to quickly enable developers to work on ARCHER2. It assumes that you are familiar with the material in quickstart-users .","title":"Quickstart for developers"},{"location":"quick-start/quickstart-developers/#compiler-wrappers","text":"When compiling code on ARCHER2, you should make use of the Cray compiler wrappers. These ensure that the correct libraries and headers (for example, MPI or Cray LibSci) will be used during the compilation and linking stages. These wrappers should be accessed by providing the following compiler names: Language Wrapper name C cc C++ CC Fortran ftn This means that you should use the wrapper names whether on the command line, in build scripts, or in configure options. It could be helpful to set some or all of the following environment variables before running a build to ensure that the build tool is aware of the wrappers: export CC=cc export CXX=CC export FC=ftn export F77=ftn export F90=ftn man pages are available for each wrapper. You can also see the full set of compiler and linker options being used by passing the -craype-verbose option to the wrapper when using it.","title":"Compiler wrappers"},{"location":"quick-start/quickstart-developers/#programming-environments","text":"On login to ARCHER2, the PrgEnv-cray module will be loaded, as will a cce module. The latter makes available Cray's compilers from the Cray Compiling Environment (CCE), while the former provides the correct wrappers and support to use them. The GNU Compiler Collection (GCC) is also available. To make use of any Programming Environment, simply swap to the correct PrgEnv module. After doing so the compiler wrappers ( cc , CC and ftn ) will correctly call the compilers from the new suite. The default version of the corresponding compiler suite will also be loaded, but you may swap to another available version if you wish. The following table summarises the suites and associated programming environments. Suite name Module Programming environment module CCE cce PrgEnv-cray GCC gcc PrgEnv-gnu As an example, after logging in you may wish to use GCC as your compiler suite. Running module swap PrgEnv-cray PrgEnv-gnu will unload the Cray environment and replace it with the GNU environment. It will also unload the cce module and load the default version of the gcc module; at the time of writing, this is GCC 9.3.0. If you need to use a different version of GCC, for example 8.1.0, you would follow up with module swap gcc gcc/8.1.0 . At this point you may invoke the compiler wrappers and they will correctly use Cray's libraries and tools in conjunction with GCC 8.1.0. When choosing the programming environment, a big factor will likely be which compilers you have previously used for your code's development. The Cray Fortran compiler is similar to the compiler you may be familiar with from ARCHER, while the Cray C and C++ compilers provided on ARCHER2 are new versions that are now derived from Clang. The GCC suite provides gcc and gfortran. Note Unlike ARCHER, the Intel compilers are not available on ARCHER2. Note We will add information on the AOCC compilers when they become available.","title":"Programming environments"},{"location":"quick-start/quickstart-developers/#useful-compiler-options","text":"The compiler options you use will depend on both the software you are building and also on the current stage of development. The following flags should be a good starting point for reasonable performance: Compilers Optimisation flags Cray C/C++ -O2 -funroll-loops -ffast-math Cray Fortran Default options GCC -O2 -ftree-vectorize -funroll-loops -ffast-math When you are happy with your code's performance you may wish to enable more aggressive optimisations; in this case you could start using the following flags. Please note, however, that these optimisations may lead to deviations from IEEE/ISO specifications. If your code relies on strict adherence then these flags may lead to it producing incorrect output. Compilers Optimisation flags Cray C/C++ -Ofast -funroll-loops Cray Fortran -O3 -hfp3 GCC -Ofast -funroll-loops Vectorisation is enabled by the Cray Fortran compiler at -O1 and above, by Cray C and C++ at -O2 and above or when using -ftree-vectorize , and by the GCC compilers at -O3 and above or when using -ftree-vectorize . You may wish to promote default real and integer types in Fortran codes from 4 to 8 bytes. In this case, the following flags may be used: Compiler Fortran real and integer promotion flags Cray Fortran -s real64 -s integer64 gfortran -freal-4-real-8 -finteger-4-integer-8 More documentation on the compilers is available through man . The pages to read are accessed as follow: Compiler suite C C++ Fortran Cray man craycc man crayCC man crayftn GNU man gcc man g++ man gfortran Note We will add information on the AOCC compilers when they become available.","title":"Useful compiler options"},{"location":"quick-start/quickstart-developers/#linking-on-archer2","text":"Executables on ARCHER2 link dynamically, and the Cray Programming Environment does not currently support static linking. This is in contrast to ARCHER where the default was to build statically.","title":"Linking on ARCHER2"},{"location":"quick-start/quickstart-developers/#using-rpaths-to-link","text":"The default behaviour of a dynamically linked executable will be to allow the linker to provide the libraries it needs at runtime by searching the paths in the LD_LIBRARY_PATH environment variable. This is flexible in that it allows an executable to use newly installed library versions without rebuilding, but in some cases you may prefer to bake the paths to specific libraries into the executable, keeping them constant. While the libraries are still dynamically loaded at run time, from the end user's point of view the resulting behaviour will be similar to that of a statically compiled executable in that they will not need to concern themselves with ensuring the linker will be able to find the libraries. This is achieved by providing RPATHs to the compiler as options. To set the compiler wrappers to do this, you can set the following environment variable: export CRAY_ADD_RPATH=yes You can also provide RPATHs directly to the compilers using the -Wl,-rpath=<path-to-directory> flag, where the provided path is to the directory containing the libraries which are themselves typically specified with flags of the type -l<library-name> .","title":"Using RPATHs to link"},{"location":"quick-start/quickstart-developers/#debugging-tools","text":"The following debugging tools are available on ARCHER2: gdb4hpc is a command-line tool working similarly to gdb \\<https://www.gnu.org/software/gdb/> that allows users to debug parallel programs. It can launch parallel programs or attach to ones already running and allows the user to step through the execution to identify the causes of any unexpected behaviour. Available via module load gdb4hpc . valgrind4hpc is a parallel memory debugging tool that aids in detection of memory leaks and errors in parallel applications. It aggregates like errors across processes and threads to simplify debugging of parallel appliciations. Available via module load valgrind4hpc . STAT , the Stack Trace Analysis Tool, generates merged stack traces for parallel applications. It also provides visualisation tools. Available via module load cray-stat . * ATP , Abnormal Termiation Processing, offers scalable core file and backtrace analysis when parallel programs crash. Output can be viewed with STAT. Available via module load atp . To get started debugging on ARCHER2, you might like to use gdb4hpc. You should first of all compile your code using the -g flag to enable debugging symbols. Once compiled, load the gdb4hpc module and start it: module load gdb4hpc gdb4hpc Once inside gdb4hpc, you can start your program's execution with the launch command: dbg all> launch $my_prog{128} ./prog In this example, a job called my_prog will be launched to run the executable file prog over 128 cores on a compute node. If you run squeue in another terminal you will be able to see it running. Inside gdb4hpc you may then step through the code's execution, continue to breakpoints that you set with break , print the values of variables at these points, and perform a backtrace on the stack if the program crashes. Debugging jobs will end when you exit gdb4hpc, or you can end them yourself by running, in this example, release $my_prog . For more information on debugging parallel codes, see the documentation at ARCHER2 User and Best Practice Guide - Debugging <../user-guide/debug> . Note We will add more information on using the debugging tools once the ARCHER2 system is available.","title":"Debugging tools"},{"location":"quick-start/quickstart-developers/#profiling-tools","text":"Profiling on ARCHER2 is provided through the Cray Performance Measurement and Analysis Tools (CrayPAT). This has a number of different components: CrayPAT the full-featured program analysis tool set. CrayPAT consists of pat_build, the utility used to instrument programs, the CrayPat run time environment, which collects the specified performance data during program execution, and pat_report, the first-level data analysis tool, used to produce text reports or export data for more sophisticated analysis CrayPAT-lite a simplified and easy-to-use version of CrayPAT that provides basic performance analysis information automatically, with a minimum of user interaction. Reveal the next-generation integrated performance analysis and code optimization tool, which enables the user to correlate performance data captured during program execution directly to the original source, and identify opportunities for further optimization. Cray PAPI components, which are support packages for those who want to access performance counters. Cray Apprentice2 the second-level data analysis tool, used to visualize, manipulate, explore, and compare sets of program performance data in a GUI environment. The above tools are made available for use by firstly loading the perftools-base module followed by either perftools (for CrayPAT, Reveal and Apprentice2) or one of the perftools-lite modules. The simplest way to get started profiling your code is with CrayPAT-lite. For example, to sample a run of a code you would load the perftools-base and perftools-lite modules, and then compile (you will receive a message that the executable is being instrumented). Performing a batch run as usual with this executable will produce a directory such as my_prog+74653-2s which can be passed to pat_report to view the results. In this example, pat_report -O calltree+src my_prog+74653-2s will produce a report containing the call tree. You can view available report keywords to be provided to the -O option by running pat_report -O -h . The available perftools-lite modules are: perftools-lite , instrumenting a basic sampling experiment. perftools-lite-events , instrumenting a tracing experiment. perftools-lite-gpu , instrumenting OpenACC and OpenMP 4 use of GPUs. perftools-lite-hbm , instrumenting for memory bandwidth usage. perftools-lite-loops , instrumenting a loop work estimate experiment. For more information on profiling parallel codes, see the documentation at ARCHER2 User and Best Practice Guide - Profiling <../user-guide/profile> . Note We will add more information on using the profiling tools once the ARCHER2 system is available.","title":"Profiling tools"},{"location":"quick-start/quickstart-developers/#useful-links","text":"Links to other documentation you may find useful: ARCHER2 User and Best Practice Guide <../user-guide/overview> - Covers all aspects of use of the ARCHER2 service. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of ARCHER2, and more advanced technical topics. Cray Programming Environment User Guide Cray Performance Measurement and Analysis Tools User Guide","title":"Useful Links"},{"location":"quick-start/quickstart-users/","text":"Quickstart for users Warning The ARCHER2 Service is not yet available. This documentation is in development. This guide aims to quickly enable new users to get up and running on ARCHER2 by running through the process of getting an ARCHER2 account, logging in and running your first job. Request an account on ARCHER2 Tip You need to use both a password and a passphrase-protected SSH key pair to log into ARCHER2. You get the password from SAFE but will need to setup your own SSH key pair and add the public part to your account via SAFE before you will be able to log in. We cover the authentication steps below. Obtain an account on the SAFE website The first step is to sign up for an account on the ARCHER2 SAFE website. This account is used to manage your user accounts and report on your usage and quotas. To do this: Go to the SAFE New User Signup Form Fill in your personal details. You can come back later and change them if you wish Click Submit You are now registered. Your SAFE password will be emailed to the email address you provided. You can then login with that email address and password. Request an ARCHER2 login account Once you have a SAFE account you will need to request a user account on ARCHER2 itself. To do this you will require a Project Code ; you usually obtain this from the Principle Investigator (PI) or project manager for the project you will be working on. Once you have the Project Code: Log into SAFE Use the Login accounts - Request new account menu item Select the correct project from the drop down list Select the ARCHER2 machine in the list of available machines Click Next Enter a username for the account Click Request The PI or project manager of the project will be asked to approve your request. After your request has been approved the account will be created and when this has been done you will receive an email. You can then come back to SAFE and pick up the initial, one use password for your new account (ARCHER2 account passwords are also sometimes referred to as LDAP passwords by the system). Generating and adding an SSH key pair How you generate your SSH key pair depends on which operating system you use and which SSH client you use to connect to ARCHER2. We will not cover the details on generating an SSH key pair here, but detailed information on generating an SSH key pair is available in the ARCHER2 User and Best Practice Guide . Once you have generated your SSH key pair, you should add the public part to your login account using SAFE: Log into SAFE Use the menu Login accounts and select the ARCHER2 account you want to add the SSH key to On the subsequent Login account details page click the Add Credential button Select SSH public key as the Credential Type and click Next Either copy and paste the public part of your SSH key into the SSH Public key box or use the button to select the public key file on your computer. Click Add to associate the public SSH key part with your account Once you have done this, your SSH key will be added to your ARCHER2 account. Remember, you will need to use both an SSH key and password to log into ARCHER2 so you will also need to collect your initial password before you can log into ARCHER2. We cover this next. Collecting your ARCHER2 password You should now collect your ARCHER2 password: Log into SAFE Use the Login accounts menu to select your new login account This will display details of your account. Use the View Login Account Password button to view your single-use ARCHER2 password. This password is generated randomly by the software. It's best to copy-and-paste it across when you log in to the service machine. After you login, you will be prompted to change it. You should enter this password again, and then you will be prompted for your new, easy-to-remember password. Your new password should conform to the ARCHER2 Password Policy . Note When you change your password on the service machine in this way, this is not reflected on the SAFE. Login to ARCHER2 To log into ARCHER2 you should use the login.archer2.ac.uk address: ssh [userID]@login.archer2.ac.uk You will first be prompted for the passphrase associated with your SSH key pair. Once you have entered your passphrase successfully, you will then be prompted for your password. You need to enter both correctly to be able to access ARCHER2. Note If your SSH key pair is not stored in the default location (usually ~/.ssh/id_rsa ) on your local system, you may need to specify the path to the private part of the key wih the -i option to ssh . For example, if your key is in a file called keys/id_rsa_archer2 you would use the command ssh -i keys/id_rsa_archer2 username@login.archer2.ac.uk to log in. Note When you first log into ARCHER2, you will be prompted to change your initial password. This is a three step process: When promoted to enter your ldap password : Re-enter the password you retrieved from SAFE When prompted to enter your new password: type in a new password When prompted to re-enter the new password: re-enter the new password Your password has now been changed Tip More information on connecting to ARCHER2 is available in the User and Best Practice Guide: Connecting to ARCHER2 . File systems and manipulating data ARCHER2 has a number of different file systems and understanding the difference between them is crucial to being able to use the system. In particular, transferring and moving data often requires a bit of thought in advance to ensure that the data is secure and in a useful form. ARCHER2 file systems are: /home : backed up for disaster recovery purposes only, data recovery for accidental deletion is not supported. NFS, available on login and service nodes. /work : not backed-up. Lustre, available on login, service and compute nodes. Top tips for managing data on ARCHER2: Do not generate huge (>1000) numbers of files in a single directory Much of the performance difference on transferring data is due to numbers of files involved in the transfer - minimise the number of files that you have to transfer by using archiving tools to improve performance. Archive directories or large numbers of files before moving them between file systems (e.g. using tar) When using tar or rsync between file systems mounted on ARCHER2 avoid using the compression options as these slow operations down (as file system bandwidth is generally better than throttling by CPU performance by using compression). Think about automating the combination and transfer of multiple files output by software on ARCHER2 to other resources. The Data Management Guide linked below provides examples of how to automatically verify the integrity of an archive and examples of how to do this. Tip Information on best practice in managing you data is available in the User and Best Practice Guide: Data management and transfer . Accessing software Software on ARCHER2 is principally accessed through environment modules. These load and unload the desired compilers, tools and libraries through the module command and its subcommands. Some will be loaded by default on login, providing a default working environment; many more will be available for use but initially unloaded, allowing you to set up the environment to suit your needs. At any stage you can check which modules have been loaded by running: module list Running the following command will display all environment modules available on ARCHER2, whether loaded or unloaded: module avail The search field for this command may be narrowed by providing the first few characters of the module name being queried. For example, all available versions and variants of VASP may be found by running: module avail vasp You will see that different versions are available for many modules. For example, vasp/5/5.4.4 and vasp/6/6.1.0 are two available versions of VASP. Furthermore, a default version may be specified and will be used if no version is provided by the user. Warning VASP is licensed software, as are some other software packages on ARCHER2. You must have a valid licence to use licensed software on ARCHER2. Often you will need to request access through the SAFE. More on this below. The module load and module add commands perform the same action, loading a module for use. Following the above, module load vasp would load the default version of VASP, while module load vasp/5/5.4.4 would specifically load version 5.4.4. A loaded module may be unloaded through the identical module unload , module remove or module delete commands, e.g. module unload vasp which would unload whichever version of VASP is currently in the environment. Rather than issuing separate unload and load commands, versions of a module may be swapped as follows: module swap vasp vasp/5/5.4.4 Other helpful commands are: module help <modulename> which provides a short description of the module module show <modulename> which displays the contents of the modulefile Points to be aware of include: Some modules will conflict with others. A simple example would be the conflict arising when trying to load a different version of an already loaded module. When a conflict occurs, the loading process will fail and an error message will be displayed. Examination of the message and the modulefiles (via module show ) should reveal the cause of the conflict and how to resolve it. The order in which modules are loaded can matter. Consider two modules which set the same variable to a different value. The final value would be that set by the module which loaded last. If you suspect that two modules may be interfering with one another, you can examine their contents with module show . Requesting access to licensed software Some of the software installed on ARCHER2 requires a user to have a valid licence agreed with the software owners/developers to be able to use it (for example, VASP). Although you will be able to load this software on ARCHER2 you will be barred from actually using it until your licence has been verified. You request access to licensed software through the EPCC SAFE (the web administration tool you used to apply for your account and retrieve your initial password) by being added to the appropriate Package Group . To request access to licensed software: Log in to SAFE Go to the Menu Login accounts and select the login account which requires access to the software Click New Package Group Request Select the software from the list of available packages and click Select Package Group Fill in as much information as possible about your license; at the very least provide the information requested at the top of the screen such as the licence holder's name and contact details. If you are covered by the license because the licence holder is your supervisor, for example, please state this. Click Submit Your request will then be processed by the ARCHER2 Service Desk who will confirm your license with the software owners/developers before enabling your access to the software on ARCHER2. This can take several days (depending on how quickly the software owners/developers take to respond) but you will be advised once this has been done. Create a job submission script To run a program on the ARCHER2 compute nodes you need to write a job submission script that tells the system how many compute nodes you want to reserve and for how long. You also need to use the srun command to launch your parallel executable. Tip For a more details on the Slurm scheduler on ARCHER2 and writing job submission scripts see the User and Best Practice Guide: Running jobs on ARCHER2 .. Warning Parallel jobs on ARCHER2 should be run from the /work file system as /home is not available on the compute nodes - you will see a chdir or file not found error if you try to run a job from the /home file system. Create a job submission script called submit.slurm in your space on the work file system using your favourite text editor. For example, using vim : auser@eslogin01:~> cd /work/t01/t01/auser auser@eslogin01:/work/t01/t01/auser> vim submit.slurm Tip You will need to use your project code and username to get to the correct directory. i.e. replace the t01 above with your project code and replace the username auser with your ARCHER2 username. Paste the following text into your job submission script, replacing ENTER_YOUR_BUDGET_CODE_HERE with your budget code e.g. e99-ham . #!/bin/bash --login #SBATCH --job-name=test_job #SBATCH --nodes=1 #SBATCH --tasks-per-node=128 #SBATCH --cores-per-task==1 #SBATCH --time=0:5:0 #SBATCH -account=ENTER_YOUR_BUDGET_CODE_HERE # Load the xthi module to get access to the xthi program module load xthi # srun launches the parallel program based on the SBATCH options srun --cpu-bind=cores xthi Submit your job to the queue You submit your job to the queues using the sbatch command: auser@eslogin01:/work/t01/t01/auser> sbatch submit.slurm Submitted batch job 23996 The value returned is your Job ID . Monitoring your job You use the squeue command to examine jobs in the queue. Use: auser@eslogin01:/work/t01/t01/auser> squeue -u $USER To list all the jobs you have in the queue. squeue on its own lists all jobs in the queue from all users. Checking the output from the job The job submission script above should write the output to a file called slurm-<jobID>.out (i.e. if the Job ID was 23996, the file would be slurm-23996.out ), you can check the contents of this file with the cat command. If the job was successful you should see output that looks something like: auser@eslogin01:/work/t01/t01/auser> cat slurm-23996.out Hello from rank 20, thread 0, on nid00001. (core affinity = 20) Hello from rank 27, thread 0, on nid00001. (core affinity = 27) Hello from rank 23, thread 0, on nid00001. (core affinity = 23) Hello from rank 34, thread 0, on nid00001. (core affinity = 34) Hello from rank 18, thread 0, on nid00001. (core affinity = 18) Hello from rank 33, thread 0, on nid00001. (core affinity = 33) Hello from rank 19, thread 0, on nid00001. (core affinity = 19) Hello from rank 22, thread 0, on nid00001. (core affinity = 22) Hello from rank 6, thread 0, on nid00001. (core affinity = 6) Hello from rank 26, thread 0, on nid00001. (core affinity = 26) Hello from rank 31, thread 0, on nid00001. (core affinity = 31) Hello from rank 21, thread 0, on nid00001. (core affinity = 21) Hello from rank 35, thread 0, on nid00001. (core affinity = 35) Hello from rank 32, thread 0, on nid00001. (core affinity = 32) Hello from rank 28, thread 0, on nid00001. (core affinity = 28) Hello from rank 25, thread 0, on nid00001. (core affinity = 25) Hello from rank 24, thread 0, on nid00001. (core affinity = 24) Hello from rank 30, thread 0, on nid00001. (core affinity = 30) Hello from rank 29, thread 0, on nid00001. (core affinity = 29) Hello from rank 10, thread 0, on nid00001. (core affinity = 10) Hello from rank 2, thread 0, on nid00001. (core affinity = 2) Hello from rank 11, thread 0, on nid00001. (core affinity = 11) Hello from rank 0, thread 0, on nid00001. (core affinity = 0) Hello from rank 1, thread 0, on nid00001. (core affinity = 1) Hello from rank 7, thread 0, on nid00001. (core affinity = 7) Hello from rank 4, thread 0, on nid00001. (core affinity = 4) Hello from rank 3, thread 0, on nid00001. (core affinity = 3) Hello from rank 5, thread 0, on nid00001. (core affinity = 5) Hello from rank 8, thread 0, on nid00001. (core affinity = 8) Hello from rank 9, thread 0, on nid00001. (core affinity = 9) Hello from rank 12, thread 0, on nid00001. (core affinity = 12) Hello from rank 13, thread 0, on nid00001. (core affinity = 13) Hello from rank 14, thread 0, on nid00001. (core affinity = 14) Hello from rank 15, thread 0, on nid00001. (core affinity = 15) Hello from rank 16, thread 0, on nid00001. (core affinity = 16) Hello from rank 17, thread 0, on nid00001. (core affinity = 17) ... output trimmed ... If something has gone wrong, you will find any error messages in the file instead of the expected output. Acknowledging ARCHER2 You should use the following phrase to acknowledge ARCHER2 in all research outputs that have used the facility: This work used the ARCHER2 UK National Supercomputing Service (https://www.archer2.ac.uk). You should also tag outputs with the keyword ARCHER2 whenever possible. Useful Links If you plan to compile your own programs on ARCHER2, you may also want to look at Quickstart guide for software developers . Links to other documentation you may find useful: ARCHER2 User and Best Practice Guide - Covers all aspects of use of the ARCHER2 service. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of ARCHER2, and more advanced technical topics. Cray Programming Environment User Guide","title":"Quickstart for users"},{"location":"quick-start/quickstart-users/#quickstart-for-users","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. This guide aims to quickly enable new users to get up and running on ARCHER2 by running through the process of getting an ARCHER2 account, logging in and running your first job.","title":"Quickstart for users"},{"location":"quick-start/quickstart-users/#request-an-account-on-archer2","text":"Tip You need to use both a password and a passphrase-protected SSH key pair to log into ARCHER2. You get the password from SAFE but will need to setup your own SSH key pair and add the public part to your account via SAFE before you will be able to log in. We cover the authentication steps below.","title":"Request an account on ARCHER2"},{"location":"quick-start/quickstart-users/#obtain-an-account-on-the-safe-website","text":"The first step is to sign up for an account on the ARCHER2 SAFE website. This account is used to manage your user accounts and report on your usage and quotas. To do this: Go to the SAFE New User Signup Form Fill in your personal details. You can come back later and change them if you wish Click Submit You are now registered. Your SAFE password will be emailed to the email address you provided. You can then login with that email address and password.","title":"Obtain an account on the SAFE website"},{"location":"quick-start/quickstart-users/#request-an-archer2-login-account","text":"Once you have a SAFE account you will need to request a user account on ARCHER2 itself. To do this you will require a Project Code ; you usually obtain this from the Principle Investigator (PI) or project manager for the project you will be working on. Once you have the Project Code: Log into SAFE Use the Login accounts - Request new account menu item Select the correct project from the drop down list Select the ARCHER2 machine in the list of available machines Click Next Enter a username for the account Click Request The PI or project manager of the project will be asked to approve your request. After your request has been approved the account will be created and when this has been done you will receive an email. You can then come back to SAFE and pick up the initial, one use password for your new account (ARCHER2 account passwords are also sometimes referred to as LDAP passwords by the system).","title":"Request an ARCHER2 login account"},{"location":"quick-start/quickstart-users/#generating-and-adding-an-ssh-key-pair","text":"How you generate your SSH key pair depends on which operating system you use and which SSH client you use to connect to ARCHER2. We will not cover the details on generating an SSH key pair here, but detailed information on generating an SSH key pair is available in the ARCHER2 User and Best Practice Guide . Once you have generated your SSH key pair, you should add the public part to your login account using SAFE: Log into SAFE Use the menu Login accounts and select the ARCHER2 account you want to add the SSH key to On the subsequent Login account details page click the Add Credential button Select SSH public key as the Credential Type and click Next Either copy and paste the public part of your SSH key into the SSH Public key box or use the button to select the public key file on your computer. Click Add to associate the public SSH key part with your account Once you have done this, your SSH key will be added to your ARCHER2 account. Remember, you will need to use both an SSH key and password to log into ARCHER2 so you will also need to collect your initial password before you can log into ARCHER2. We cover this next.","title":"Generating and adding an SSH key pair"},{"location":"quick-start/quickstart-users/#collecting-your-archer2-password","text":"You should now collect your ARCHER2 password: Log into SAFE Use the Login accounts menu to select your new login account This will display details of your account. Use the View Login Account Password button to view your single-use ARCHER2 password. This password is generated randomly by the software. It's best to copy-and-paste it across when you log in to the service machine. After you login, you will be prompted to change it. You should enter this password again, and then you will be prompted for your new, easy-to-remember password. Your new password should conform to the ARCHER2 Password Policy . Note When you change your password on the service machine in this way, this is not reflected on the SAFE.","title":"Collecting your ARCHER2 password"},{"location":"quick-start/quickstart-users/#login-to-archer2","text":"To log into ARCHER2 you should use the login.archer2.ac.uk address: ssh [userID]@login.archer2.ac.uk You will first be prompted for the passphrase associated with your SSH key pair. Once you have entered your passphrase successfully, you will then be prompted for your password. You need to enter both correctly to be able to access ARCHER2. Note If your SSH key pair is not stored in the default location (usually ~/.ssh/id_rsa ) on your local system, you may need to specify the path to the private part of the key wih the -i option to ssh . For example, if your key is in a file called keys/id_rsa_archer2 you would use the command ssh -i keys/id_rsa_archer2 username@login.archer2.ac.uk to log in. Note When you first log into ARCHER2, you will be prompted to change your initial password. This is a three step process: When promoted to enter your ldap password : Re-enter the password you retrieved from SAFE When prompted to enter your new password: type in a new password When prompted to re-enter the new password: re-enter the new password Your password has now been changed Tip More information on connecting to ARCHER2 is available in the User and Best Practice Guide: Connecting to ARCHER2 .","title":"Login to ARCHER2"},{"location":"quick-start/quickstart-users/#file-systems-and-manipulating-data","text":"ARCHER2 has a number of different file systems and understanding the difference between them is crucial to being able to use the system. In particular, transferring and moving data often requires a bit of thought in advance to ensure that the data is secure and in a useful form. ARCHER2 file systems are: /home : backed up for disaster recovery purposes only, data recovery for accidental deletion is not supported. NFS, available on login and service nodes. /work : not backed-up. Lustre, available on login, service and compute nodes. Top tips for managing data on ARCHER2: Do not generate huge (>1000) numbers of files in a single directory Much of the performance difference on transferring data is due to numbers of files involved in the transfer - minimise the number of files that you have to transfer by using archiving tools to improve performance. Archive directories or large numbers of files before moving them between file systems (e.g. using tar) When using tar or rsync between file systems mounted on ARCHER2 avoid using the compression options as these slow operations down (as file system bandwidth is generally better than throttling by CPU performance by using compression). Think about automating the combination and transfer of multiple files output by software on ARCHER2 to other resources. The Data Management Guide linked below provides examples of how to automatically verify the integrity of an archive and examples of how to do this. Tip Information on best practice in managing you data is available in the User and Best Practice Guide: Data management and transfer .","title":"File systems and manipulating data"},{"location":"quick-start/quickstart-users/#accessing-software","text":"Software on ARCHER2 is principally accessed through environment modules. These load and unload the desired compilers, tools and libraries through the module command and its subcommands. Some will be loaded by default on login, providing a default working environment; many more will be available for use but initially unloaded, allowing you to set up the environment to suit your needs. At any stage you can check which modules have been loaded by running: module list Running the following command will display all environment modules available on ARCHER2, whether loaded or unloaded: module avail The search field for this command may be narrowed by providing the first few characters of the module name being queried. For example, all available versions and variants of VASP may be found by running: module avail vasp You will see that different versions are available for many modules. For example, vasp/5/5.4.4 and vasp/6/6.1.0 are two available versions of VASP. Furthermore, a default version may be specified and will be used if no version is provided by the user. Warning VASP is licensed software, as are some other software packages on ARCHER2. You must have a valid licence to use licensed software on ARCHER2. Often you will need to request access through the SAFE. More on this below. The module load and module add commands perform the same action, loading a module for use. Following the above, module load vasp would load the default version of VASP, while module load vasp/5/5.4.4 would specifically load version 5.4.4. A loaded module may be unloaded through the identical module unload , module remove or module delete commands, e.g. module unload vasp which would unload whichever version of VASP is currently in the environment. Rather than issuing separate unload and load commands, versions of a module may be swapped as follows: module swap vasp vasp/5/5.4.4 Other helpful commands are: module help <modulename> which provides a short description of the module module show <modulename> which displays the contents of the modulefile Points to be aware of include: Some modules will conflict with others. A simple example would be the conflict arising when trying to load a different version of an already loaded module. When a conflict occurs, the loading process will fail and an error message will be displayed. Examination of the message and the modulefiles (via module show ) should reveal the cause of the conflict and how to resolve it. The order in which modules are loaded can matter. Consider two modules which set the same variable to a different value. The final value would be that set by the module which loaded last. If you suspect that two modules may be interfering with one another, you can examine their contents with module show .","title":"Accessing software"},{"location":"quick-start/quickstart-users/#requesting-access-to-licensed-software","text":"Some of the software installed on ARCHER2 requires a user to have a valid licence agreed with the software owners/developers to be able to use it (for example, VASP). Although you will be able to load this software on ARCHER2 you will be barred from actually using it until your licence has been verified. You request access to licensed software through the EPCC SAFE (the web administration tool you used to apply for your account and retrieve your initial password) by being added to the appropriate Package Group . To request access to licensed software: Log in to SAFE Go to the Menu Login accounts and select the login account which requires access to the software Click New Package Group Request Select the software from the list of available packages and click Select Package Group Fill in as much information as possible about your license; at the very least provide the information requested at the top of the screen such as the licence holder's name and contact details. If you are covered by the license because the licence holder is your supervisor, for example, please state this. Click Submit Your request will then be processed by the ARCHER2 Service Desk who will confirm your license with the software owners/developers before enabling your access to the software on ARCHER2. This can take several days (depending on how quickly the software owners/developers take to respond) but you will be advised once this has been done.","title":"Requesting access to licensed software"},{"location":"quick-start/quickstart-users/#create-a-job-submission-script","text":"To run a program on the ARCHER2 compute nodes you need to write a job submission script that tells the system how many compute nodes you want to reserve and for how long. You also need to use the srun command to launch your parallel executable. Tip For a more details on the Slurm scheduler on ARCHER2 and writing job submission scripts see the User and Best Practice Guide: Running jobs on ARCHER2 .. Warning Parallel jobs on ARCHER2 should be run from the /work file system as /home is not available on the compute nodes - you will see a chdir or file not found error if you try to run a job from the /home file system. Create a job submission script called submit.slurm in your space on the work file system using your favourite text editor. For example, using vim : auser@eslogin01:~> cd /work/t01/t01/auser auser@eslogin01:/work/t01/t01/auser> vim submit.slurm Tip You will need to use your project code and username to get to the correct directory. i.e. replace the t01 above with your project code and replace the username auser with your ARCHER2 username. Paste the following text into your job submission script, replacing ENTER_YOUR_BUDGET_CODE_HERE with your budget code e.g. e99-ham . #!/bin/bash --login #SBATCH --job-name=test_job #SBATCH --nodes=1 #SBATCH --tasks-per-node=128 #SBATCH --cores-per-task==1 #SBATCH --time=0:5:0 #SBATCH -account=ENTER_YOUR_BUDGET_CODE_HERE # Load the xthi module to get access to the xthi program module load xthi # srun launches the parallel program based on the SBATCH options srun --cpu-bind=cores xthi","title":"Create a job submission script"},{"location":"quick-start/quickstart-users/#submit-your-job-to-the-queue","text":"You submit your job to the queues using the sbatch command: auser@eslogin01:/work/t01/t01/auser> sbatch submit.slurm Submitted batch job 23996 The value returned is your Job ID .","title":"Submit your job to the queue"},{"location":"quick-start/quickstart-users/#monitoring-your-job","text":"You use the squeue command to examine jobs in the queue. Use: auser@eslogin01:/work/t01/t01/auser> squeue -u $USER To list all the jobs you have in the queue. squeue on its own lists all jobs in the queue from all users.","title":"Monitoring your job"},{"location":"quick-start/quickstart-users/#checking-the-output-from-the-job","text":"The job submission script above should write the output to a file called slurm-<jobID>.out (i.e. if the Job ID was 23996, the file would be slurm-23996.out ), you can check the contents of this file with the cat command. If the job was successful you should see output that looks something like: auser@eslogin01:/work/t01/t01/auser> cat slurm-23996.out Hello from rank 20, thread 0, on nid00001. (core affinity = 20) Hello from rank 27, thread 0, on nid00001. (core affinity = 27) Hello from rank 23, thread 0, on nid00001. (core affinity = 23) Hello from rank 34, thread 0, on nid00001. (core affinity = 34) Hello from rank 18, thread 0, on nid00001. (core affinity = 18) Hello from rank 33, thread 0, on nid00001. (core affinity = 33) Hello from rank 19, thread 0, on nid00001. (core affinity = 19) Hello from rank 22, thread 0, on nid00001. (core affinity = 22) Hello from rank 6, thread 0, on nid00001. (core affinity = 6) Hello from rank 26, thread 0, on nid00001. (core affinity = 26) Hello from rank 31, thread 0, on nid00001. (core affinity = 31) Hello from rank 21, thread 0, on nid00001. (core affinity = 21) Hello from rank 35, thread 0, on nid00001. (core affinity = 35) Hello from rank 32, thread 0, on nid00001. (core affinity = 32) Hello from rank 28, thread 0, on nid00001. (core affinity = 28) Hello from rank 25, thread 0, on nid00001. (core affinity = 25) Hello from rank 24, thread 0, on nid00001. (core affinity = 24) Hello from rank 30, thread 0, on nid00001. (core affinity = 30) Hello from rank 29, thread 0, on nid00001. (core affinity = 29) Hello from rank 10, thread 0, on nid00001. (core affinity = 10) Hello from rank 2, thread 0, on nid00001. (core affinity = 2) Hello from rank 11, thread 0, on nid00001. (core affinity = 11) Hello from rank 0, thread 0, on nid00001. (core affinity = 0) Hello from rank 1, thread 0, on nid00001. (core affinity = 1) Hello from rank 7, thread 0, on nid00001. (core affinity = 7) Hello from rank 4, thread 0, on nid00001. (core affinity = 4) Hello from rank 3, thread 0, on nid00001. (core affinity = 3) Hello from rank 5, thread 0, on nid00001. (core affinity = 5) Hello from rank 8, thread 0, on nid00001. (core affinity = 8) Hello from rank 9, thread 0, on nid00001. (core affinity = 9) Hello from rank 12, thread 0, on nid00001. (core affinity = 12) Hello from rank 13, thread 0, on nid00001. (core affinity = 13) Hello from rank 14, thread 0, on nid00001. (core affinity = 14) Hello from rank 15, thread 0, on nid00001. (core affinity = 15) Hello from rank 16, thread 0, on nid00001. (core affinity = 16) Hello from rank 17, thread 0, on nid00001. (core affinity = 17) ... output trimmed ... If something has gone wrong, you will find any error messages in the file instead of the expected output.","title":"Checking the output from the job"},{"location":"quick-start/quickstart-users/#acknowledging-archer2","text":"You should use the following phrase to acknowledge ARCHER2 in all research outputs that have used the facility: This work used the ARCHER2 UK National Supercomputing Service (https://www.archer2.ac.uk). You should also tag outputs with the keyword ARCHER2 whenever possible.","title":"Acknowledging ARCHER2"},{"location":"quick-start/quickstart-users/#useful-links","text":"If you plan to compile your own programs on ARCHER2, you may also want to look at Quickstart guide for software developers . Links to other documentation you may find useful: ARCHER2 User and Best Practice Guide - Covers all aspects of use of the ARCHER2 service. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of ARCHER2, and more advanced technical topics. Cray Programming Environment User Guide","title":"Useful Links"},{"location":"research-software/","text":"Overview Warning The ARCHER2 Service is not yet available. This documentation is in development. Information on each of the centrally-installed Research Software packages, versions available, how to get access, example job submission scripts, good practice for getting best performance, links to associated training and webinars, links to associated technical reports (eCSE final reports, white papers), links to instruction manuals and further information. Centrally supported packages ARCHER2 provides a number of research software packages as *centrally supported packages*. Many of these packages are free to use, but others require a license (which you, or your research group, need to supply). The centrally supported package will usually be the current stable release, to include major releases and significant updates. We will usually not maintain older versions and versions no longer supported by the developers of the package. The following sections provide details on access to each of the centrally supported packages: castep/castep code-saturne/code-saturne chemshell/chemshell cp2k/cp2k elk/elk fenics/fenics gromacs/gromacs lammps/lammps mo-unified-model/mo-unified-model mitgcm/mitgcm namd/namd nektar++/nektar++ nemo/nemo nwchem/nwchem onetep/onetep openfoam/openfoam qe/qe vasp/vasp Not on the list? If the code you are interested in is not in the above list, we may still be able to help you install your own version, either individually, or as a project. Please contact the Service Desk.","title":"Overview"},{"location":"research-software/#overview","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. Information on each of the centrally-installed Research Software packages, versions available, how to get access, example job submission scripts, good practice for getting best performance, links to associated training and webinars, links to associated technical reports (eCSE final reports, white papers), links to instruction manuals and further information.","title":"Overview"},{"location":"research-software/#centrally-supported-packages","text":"ARCHER2 provides a number of research software packages as *centrally supported packages*. Many of these packages are free to use, but others require a license (which you, or your research group, need to supply). The centrally supported package will usually be the current stable release, to include major releases and significant updates. We will usually not maintain older versions and versions no longer supported by the developers of the package. The following sections provide details on access to each of the centrally supported packages: castep/castep code-saturne/code-saturne chemshell/chemshell cp2k/cp2k elk/elk fenics/fenics gromacs/gromacs lammps/lammps mo-unified-model/mo-unified-model mitgcm/mitgcm namd/namd nektar++/nektar++ nemo/nemo nwchem/nwchem onetep/onetep openfoam/openfoam qe/qe vasp/vasp","title":"Centrally supported packages"},{"location":"research-software/#not-on-the-list","text":"If the code you are interested in is not in the above list, we may still be able to help you install your own version, either individually, or as a project. Please contact the Service Desk.","title":"Not on the list?"},{"location":"software-libraries/","text":"Overview Warning The ARCHER2 Service is not yet available. This documentation is in development. This section will provide information on each of the centrally-installed software libraries including: versions available, how to get access, good practice for getting best performance, links to associated training and webinars, links to associated technical reports (eCSE final reports, white papers), links to instruction manuals and further information. Software libraries that will be covered: ARPACK BLACS/ScaLAPACK BLAS/LAPACK Boost Eigen ELPA FFTW GNU Scientific Library (GSL) HDF5/parallel HDF5 HYPRE METIS MUMPS NetCDF ParaFEM ParMETIS PETSc Scotch SLEPC SUNDIALS SuperLU_DIST SuperLU Trilinos Zoltan","title":"Overview"},{"location":"software-libraries/#overview","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. This section will provide information on each of the centrally-installed software libraries including: versions available, how to get access, good practice for getting best performance, links to associated training and webinars, links to associated technical reports (eCSE final reports, white papers), links to instruction manuals and further information. Software libraries that will be covered: ARPACK BLACS/ScaLAPACK BLAS/LAPACK Boost Eigen ELPA FFTW GNU Scientific Library (GSL) HDF5/parallel HDF5 HYPRE METIS MUMPS NetCDF ParaFEM ParMETIS PETSc Scotch SLEPC SUNDIALS SuperLU_DIST SuperLU Trilinos Zoltan","title":"Overview"},{"location":"user-guide/","text":"Overview Warning The ARCHER2 Service is not yet available. This documentation is in development. The ARCHER2 User and Best Practice Guide covers all aspects of use of the ARCHER2 service. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of ARCHER2 and more advanced technical topics. The User and Best Practice Guide contains the following sections: connecting data sw-environment scheduler io dev-environment containers python analysis debug profile","title":"Index"},{"location":"user-guide/#overview","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. The ARCHER2 User and Best Practice Guide covers all aspects of use of the ARCHER2 service. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of ARCHER2 and more advanced technical topics. The User and Best Practice Guide contains the following sections: connecting data sw-environment scheduler io dev-environment containers python analysis debug profile","title":"Overview"},{"location":"user-guide/analysis/","text":"Data analysis Warning The ARCHER2 Service is not yet available. This documentation is in development. How to analyse data on ARCHER2, including use of pre- and post-processing.","title":"Analysis"},{"location":"user-guide/analysis/#data-analysis","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. How to analyse data on ARCHER2, including use of pre- and post-processing.","title":"Data analysis"},{"location":"user-guide/connecting/","text":"Connecting to ARCHER2 Warning The ARCHER2 Service is not yet available. This documentation is in development. On the ARCHER2 system interactive access can be achieved via SSH, either directly from a command line terminal or using an SSH client. In addition data can be transferred to and from the ARCHER2 system using scp from the command line or by using a file transfer client see the data chapter of the User Guide for more information on transferring data. This section covers the basic connection methods. The connection procedure is then expanded on and the use of SSH agent is described for ease of access. Interactive access To log into ARCHER2 you should use the \"login.archer2.ac.uk\" address: ssh [userID]@login.archer2.ac.uk (where you replace [userID] with your ARCHER2 user name). Initial passwords The SAFE web interface is used to provide your initial password for logging onto ARCHER2 (see the ARCHER2 SAFE Documentation for more details on requesting accounts and picking up passwords). When you log into ARCHER2 for the first time you will be asked to change your password. Once you have logged in, the password change sequence is: Enter your current password (this is your one-shot password from the SAFE. Enter a new password that conforms with the ARCHER2 password policy. Re-enter the same new password. You will be logged out and can now log back in with your new password. Note: you may now change your password on the ARCHER2 machine itself using the passwd command. This change will not be reflected in the SAFE. If you forget your password, you should use the SAFE to request a new one-shot password. SSH Clients Interaction with ARCHER2 is done remotely, over an encrypted communication channel, Secure Shell version 2 (SSH-2). This allows command-line access to one of the login nodes of a ARCHER2, from which you can run commands or use a command-line text editor to edit files. SSH can also be used to run graphical programs such as GUI text editors and debuggers when used in conjunction with an X client. Logging in from Linux and macOS Linux distributions and macOS each come installed with a terminal application that can be use for SSH access to the login nodes. Linux users will have different terminals depending on their distribution and window manager (e.g. GNOME Terminal in GNOME, Konsole in KDE). Consult your Linux distribution's documentation for details on how to load a terminal. macOS users can use the Terminal application, located in the Utilities folder within the Applications folder. You can use the following command from the terminal window to login into ARCHER2: ssh [userID]@login.archer2.ac.uk To allow remote programs, especially graphical applications to control your local display, such as being able to open up a new GUI window (such as for a debugger), use: ssh -X username@login.ARCHER2.ac.uk Some sites recommend using the -Y flag. While this can fix some compatibility issues, the -X flag is more secure. Current macOS systems do not have an X window system installed by default. Users should install the XQuartz package to allow for SSH with X11 forwarding on macOS systems: XQuartz website Logging in from Windows using MobaXterm A typical Windows installation will not include a terminal client, though there are various clients available. We recommend all our Windows users to download and install MobaXterm to access ARCHER2. It is very easy to use and includes an integrated X server with SSH client to run any graphical applications on ARCHER2. You can download MobaXterm Home Edition (Installer Edition) from the following link: Install MobaXterm Double-click the downloaded Microsoft Installer file (.msi), and the Windows wizard will automatically guides you through the installation process. Note, you might need to have administrator rights to install on some Windows OS. Also make sure to check whether Windows Firewall hasn't blocked any features of this program after installation. Start MobaXterm using, for example, the icon added to the Start menu during the installation process. If you would like to run any small remote GUI applications, then make sure to use -X option along with the ssh command (see above) to enable X11 forwarding, which allows you to run graphical clients on your local X server. Making access more convenient using a SSH Agent Using a SSH Agent makes accessing the resources more convenient as you only have to enter your passphrase once per day to access any remote resource - this can include accessing resources via a chain of SSH sessions. This approach combines the security of having a passphrase to access remote resources with the convenience of having password-less access. Having this sort of access set up makes it extremely convenient to use client applications to access remote resources, for example: the Tramp Emacs plugin that allows you to access and edit files on a remote host as if they are local files; the Parallel Tools Platform for the Eclipse IDE that allows you to edit your source code on a local Eclipse installation and compile and test on a remote host; Note: this description applies if your local machine is Linux or macOS. The procedure can also be used on Windows using the PuTTY SSH terminal with the PuTTYgen key pair generation tool and the Pageant SSH Agent. See the PuTTY documentation <http://the.earth.li/~sgtatham/putty/0.62/htmldoc/> __ for more information on how to use these tools. Note: not all remote hosts allow connections using a SSH key pair. If you find this method does not work it is worth checking with the remote site that such connections are allowed. Setup a SSH key pair protected by a passphrase Using a terminal (the command line), set up a key pair that contains your e-mail address and enter a passphrase you will use to unlock the key: ssh-keygen -t rsa -C \"your@email.com\" ... -bash-4.1$ ssh-keygen -t rsa -C \"your@email.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Home/user/.ssh/id_rsa): [Enter] Enter passphrase (empty for no passphrase): [Passphrase] Enter same passphrase again: [Passphrase] Your identification has been saved in /Home/user/.ssh/id_rsa. Your public key has been saved in /Home/user/.ssh/id_rsa.pub. The key fingerprint is: 03:d4:c4:6d:58:0a:e2:4a:f8:73:9a:e8:e3:07:16:c8 your@email.com The key's randomart image is: +--[ RSA 2048]----+ | . ...+o++++. | | . . . =o.. | |+ . . .......o o | |oE . . | |o = . S | |. +.+ . | |. oo | |. . | | .. | +-----------------+ (remember to replace your@email.com with your e-mail address). Copy the public part of the key to the remote host Using you normal login password, add the public part of your key pair to the authorized\\_keys file on the remote host you wish to connect to using the SSH Agent. This can be achieved by appending the contents of the public part of the key to the remote file: -bash-4.1$ cat ~/.ssh/id_rsa.pub | ssh user@login.archer2.ac.uk 'cat - >> ~/.ssh/authorized_keys' Password: [Password] (remember to replace user with your username). Now you can test that your key pair is working correctly by attempting to connect to the remote host and run a command. You should be asked for your key pair passphase (which you entered when you created the key pair) rather than your remote machine password . -bash-4.1$ ssh user@login.archer2.ac.uk 'date' Enter passphrase for key '/Home/user/.ssh/id_rsa': [Passphrase] Wed May 8 10:36:47 BST 2013 (remember to replace user with your username). Enabling the SSH Agent So far we have just replaced the need to enter a password to access a remote host with the need to enter a key pair passphrase. The next step is to enable an SSH Agent on your local system so that you only have to enter the passphrase once per day and after that you will be able to access the remote system without entering the passphrase. Most modern Linux distributions (and macOS) should have ssh-agent running by default. If your system does not then you should find the instructions for enabling it in your distribution using Google. To add the private part of your key pair to the SSH Agent, use the 'ssh-add' command (on your local machine), you will need to enter your passphrase one more time: -bash-4.1$ ssh-add ~/.ssh/id_rsa Enter passphrase for Home/user.ssh/id_rsa: [Passphrase] Identity added: Home/user.ssh/id_rsa (Home/user.ssh/id_rsa) Now you can test that you can access the remote host without needing to enter your passphrase: -bash-4.1$ ssh user@login.ARCHER2.ac.uk 'date' Warning: Permanently added the RSA host key for IP address '192.62.216.27' to the list of known hosts. Wed May 8 10:42:55 BST 2013 (remember to replace user with your username). Adding access to other remote machines If you have more than one remote host that you access regularly, you can add the public part of your key pair to the 'authorized_keys' file on any hosts you wish to access by repeating step 2 above. SSH Agent forwarding Now that you have enabled an SSH Agent to access remote resources you can perform an additional configuration step that will allow you to access all hosts that have your public key part uploaded from any host you connect to with the SSH Agent without the need to install the private part of the key pair anywhere except your local machine. This increases the security of the key pair as the private part is only stored in one place (your local machine) and makes access more convenient (as you only need to enter your passphrase once on your local machine to enable access between all machines that have the public part of the key pair). Forwarding is controlled by a configuration file located on your local machine at .ssh/config . Each remote site (or group of sites) can have an entry in this file which may look something like: Host archer2 HostName login.ARCHER2.ac.uk User user ForwardAgent yes (remember to replace user with your username). The Host archer2 line defines a short name for the entry. In this case, instead of typing ssh login.archer2.ac.uk to access the ARCHER2 login nodes, you could use ssh archer2 instead. The remaining lines define the options for the archer2 host. Hostname login.archer2.ac.uk - defines the full address of the host User username - defines the username to use by default for this host (replace \"username\" with your own username on the remote host) ForwardAgent yes - tells SSH to forward the local SSH Agent to the remote host, this is the option that allows you to store the private part of your key on your local machine only and export the access to remote sites Now you can use SSH to access ARCHER2 without needing to enter my username or the full hostname every time: -bash-4.1$ ssh archer2 'date' Tue Dec 20 16:48:32 GMT 2016 You can set up as many of these entries as you need in your local configuration file. Other options are available. See the ssh_config man page <http://linux.die.net/man/5/ssh_config> __ (or man ssh_config on any machine with SSH installed) for a description of the SSH configuration file.","title":"Connecting to ARCHER2"},{"location":"user-guide/connecting/#connecting-to-archer2","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. On the ARCHER2 system interactive access can be achieved via SSH, either directly from a command line terminal or using an SSH client. In addition data can be transferred to and from the ARCHER2 system using scp from the command line or by using a file transfer client see the data chapter of the User Guide for more information on transferring data. This section covers the basic connection methods. The connection procedure is then expanded on and the use of SSH agent is described for ease of access.","title":"Connecting to ARCHER2"},{"location":"user-guide/connecting/#interactive-access","text":"To log into ARCHER2 you should use the \"login.archer2.ac.uk\" address: ssh [userID]@login.archer2.ac.uk (where you replace [userID] with your ARCHER2 user name).","title":"Interactive access"},{"location":"user-guide/connecting/#initial-passwords","text":"The SAFE web interface is used to provide your initial password for logging onto ARCHER2 (see the ARCHER2 SAFE Documentation for more details on requesting accounts and picking up passwords). When you log into ARCHER2 for the first time you will be asked to change your password. Once you have logged in, the password change sequence is: Enter your current password (this is your one-shot password from the SAFE. Enter a new password that conforms with the ARCHER2 password policy. Re-enter the same new password. You will be logged out and can now log back in with your new password. Note: you may now change your password on the ARCHER2 machine itself using the passwd command. This change will not be reflected in the SAFE. If you forget your password, you should use the SAFE to request a new one-shot password.","title":"Initial passwords"},{"location":"user-guide/connecting/#ssh-clients","text":"Interaction with ARCHER2 is done remotely, over an encrypted communication channel, Secure Shell version 2 (SSH-2). This allows command-line access to one of the login nodes of a ARCHER2, from which you can run commands or use a command-line text editor to edit files. SSH can also be used to run graphical programs such as GUI text editors and debuggers when used in conjunction with an X client.","title":"SSH Clients"},{"location":"user-guide/connecting/#logging-in-from-linux-and-macos","text":"Linux distributions and macOS each come installed with a terminal application that can be use for SSH access to the login nodes. Linux users will have different terminals depending on their distribution and window manager (e.g. GNOME Terminal in GNOME, Konsole in KDE). Consult your Linux distribution's documentation for details on how to load a terminal. macOS users can use the Terminal application, located in the Utilities folder within the Applications folder. You can use the following command from the terminal window to login into ARCHER2: ssh [userID]@login.archer2.ac.uk To allow remote programs, especially graphical applications to control your local display, such as being able to open up a new GUI window (such as for a debugger), use: ssh -X username@login.ARCHER2.ac.uk Some sites recommend using the -Y flag. While this can fix some compatibility issues, the -X flag is more secure. Current macOS systems do not have an X window system installed by default. Users should install the XQuartz package to allow for SSH with X11 forwarding on macOS systems: XQuartz website","title":"Logging in from Linux and macOS"},{"location":"user-guide/connecting/#logging-in-from-windows-using-mobaxterm","text":"A typical Windows installation will not include a terminal client, though there are various clients available. We recommend all our Windows users to download and install MobaXterm to access ARCHER2. It is very easy to use and includes an integrated X server with SSH client to run any graphical applications on ARCHER2. You can download MobaXterm Home Edition (Installer Edition) from the following link: Install MobaXterm Double-click the downloaded Microsoft Installer file (.msi), and the Windows wizard will automatically guides you through the installation process. Note, you might need to have administrator rights to install on some Windows OS. Also make sure to check whether Windows Firewall hasn't blocked any features of this program after installation. Start MobaXterm using, for example, the icon added to the Start menu during the installation process. If you would like to run any small remote GUI applications, then make sure to use -X option along with the ssh command (see above) to enable X11 forwarding, which allows you to run graphical clients on your local X server.","title":"Logging in from Windows using MobaXterm"},{"location":"user-guide/connecting/#making-access-more-convenient-using-a-ssh-agent","text":"Using a SSH Agent makes accessing the resources more convenient as you only have to enter your passphrase once per day to access any remote resource - this can include accessing resources via a chain of SSH sessions. This approach combines the security of having a passphrase to access remote resources with the convenience of having password-less access. Having this sort of access set up makes it extremely convenient to use client applications to access remote resources, for example: the Tramp Emacs plugin that allows you to access and edit files on a remote host as if they are local files; the Parallel Tools Platform for the Eclipse IDE that allows you to edit your source code on a local Eclipse installation and compile and test on a remote host; Note: this description applies if your local machine is Linux or macOS. The procedure can also be used on Windows using the PuTTY SSH terminal with the PuTTYgen key pair generation tool and the Pageant SSH Agent. See the PuTTY documentation <http://the.earth.li/~sgtatham/putty/0.62/htmldoc/> __ for more information on how to use these tools. Note: not all remote hosts allow connections using a SSH key pair. If you find this method does not work it is worth checking with the remote site that such connections are allowed.","title":"Making access more convenient using a SSH Agent"},{"location":"user-guide/connecting/#setup-a-ssh-key-pair-protected-by-a-passphrase","text":"Using a terminal (the command line), set up a key pair that contains your e-mail address and enter a passphrase you will use to unlock the key: ssh-keygen -t rsa -C \"your@email.com\" ... -bash-4.1$ ssh-keygen -t rsa -C \"your@email.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Home/user/.ssh/id_rsa): [Enter] Enter passphrase (empty for no passphrase): [Passphrase] Enter same passphrase again: [Passphrase] Your identification has been saved in /Home/user/.ssh/id_rsa. Your public key has been saved in /Home/user/.ssh/id_rsa.pub. The key fingerprint is: 03:d4:c4:6d:58:0a:e2:4a:f8:73:9a:e8:e3:07:16:c8 your@email.com The key's randomart image is: +--[ RSA 2048]----+ | . ...+o++++. | | . . . =o.. | |+ . . .......o o | |oE . . | |o = . S | |. +.+ . | |. oo | |. . | | .. | +-----------------+ (remember to replace your@email.com with your e-mail address).","title":"Setup a SSH key pair protected by a passphrase"},{"location":"user-guide/connecting/#copy-the-public-part-of-the-key-to-the-remote-host","text":"Using you normal login password, add the public part of your key pair to the authorized\\_keys file on the remote host you wish to connect to using the SSH Agent. This can be achieved by appending the contents of the public part of the key to the remote file: -bash-4.1$ cat ~/.ssh/id_rsa.pub | ssh user@login.archer2.ac.uk 'cat - >> ~/.ssh/authorized_keys' Password: [Password] (remember to replace user with your username). Now you can test that your key pair is working correctly by attempting to connect to the remote host and run a command. You should be asked for your key pair passphase (which you entered when you created the key pair) rather than your remote machine password . -bash-4.1$ ssh user@login.archer2.ac.uk 'date' Enter passphrase for key '/Home/user/.ssh/id_rsa': [Passphrase] Wed May 8 10:36:47 BST 2013 (remember to replace user with your username).","title":"Copy the public part of the key to the remote host"},{"location":"user-guide/connecting/#enabling-the-ssh-agent","text":"So far we have just replaced the need to enter a password to access a remote host with the need to enter a key pair passphrase. The next step is to enable an SSH Agent on your local system so that you only have to enter the passphrase once per day and after that you will be able to access the remote system without entering the passphrase. Most modern Linux distributions (and macOS) should have ssh-agent running by default. If your system does not then you should find the instructions for enabling it in your distribution using Google. To add the private part of your key pair to the SSH Agent, use the 'ssh-add' command (on your local machine), you will need to enter your passphrase one more time: -bash-4.1$ ssh-add ~/.ssh/id_rsa Enter passphrase for Home/user.ssh/id_rsa: [Passphrase] Identity added: Home/user.ssh/id_rsa (Home/user.ssh/id_rsa) Now you can test that you can access the remote host without needing to enter your passphrase: -bash-4.1$ ssh user@login.ARCHER2.ac.uk 'date' Warning: Permanently added the RSA host key for IP address '192.62.216.27' to the list of known hosts. Wed May 8 10:42:55 BST 2013 (remember to replace user with your username).","title":"Enabling the SSH Agent"},{"location":"user-guide/connecting/#adding-access-to-other-remote-machines","text":"If you have more than one remote host that you access regularly, you can add the public part of your key pair to the 'authorized_keys' file on any hosts you wish to access by repeating step 2 above.","title":"Adding access to other remote machines"},{"location":"user-guide/connecting/#ssh-agent-forwarding","text":"Now that you have enabled an SSH Agent to access remote resources you can perform an additional configuration step that will allow you to access all hosts that have your public key part uploaded from any host you connect to with the SSH Agent without the need to install the private part of the key pair anywhere except your local machine. This increases the security of the key pair as the private part is only stored in one place (your local machine) and makes access more convenient (as you only need to enter your passphrase once on your local machine to enable access between all machines that have the public part of the key pair). Forwarding is controlled by a configuration file located on your local machine at .ssh/config . Each remote site (or group of sites) can have an entry in this file which may look something like: Host archer2 HostName login.ARCHER2.ac.uk User user ForwardAgent yes (remember to replace user with your username). The Host archer2 line defines a short name for the entry. In this case, instead of typing ssh login.archer2.ac.uk to access the ARCHER2 login nodes, you could use ssh archer2 instead. The remaining lines define the options for the archer2 host. Hostname login.archer2.ac.uk - defines the full address of the host User username - defines the username to use by default for this host (replace \"username\" with your own username on the remote host) ForwardAgent yes - tells SSH to forward the local SSH Agent to the remote host, this is the option that allows you to store the private part of your key on your local machine only and export the access to remote sites Now you can use SSH to access ARCHER2 without needing to enter my username or the full hostname every time: -bash-4.1$ ssh archer2 'date' Tue Dec 20 16:48:32 GMT 2016 You can set up as many of these entries as you need in your local configuration file. Other options are available. See the ssh_config man page <http://linux.die.net/man/5/ssh_config> __ (or man ssh_config on any machine with SSH installed) for a description of the SSH configuration file.","title":"SSH Agent forwarding"},{"location":"user-guide/containers/","text":"Containers Warning The ARCHER2 Service is not yet available. This documentation is in development. This page was originally based on the documentation at the University of Sheffield HPC service <http://docs.hpc.shef.ac.uk/en/latest/sharc/software/apps/singularity.html> . Designed around the notion of mobility of compute and reproducible science, Singularity enables users to have full control of their operating system environment. This means that a non-privileged user can \"swap out\" the Linux operating system and environment on the host for a Linux OS and environment that they control. So if the host system is running CentOS Linux but your application runs in Ubuntu Linux with a particular software stack; you can create an Ubuntu image, install your software into that image, copy the image to another host (e.g. ARCHER2), and run your application on that host in it\u2019s native Ubuntu environment. Singularity also allows you to leverage the resources of whatever host you are on. This includes high-speed interconnects (i.e. Infinband on ARCHER2), file systems (i.e. /lustre on ARCHER2) and potentially other resources (e.g. the licensed Intel compilers on ARCHER2). Note: Singularity only supports Linux containers. You cannot create images that use Windows or macOS (this is a restriction of the containerisation model rather than Singularity). Useful Links Singularity website Singularity documentation About Singularity Containers (Images) Similar to Docker, a Singularity container (or, more commonly, image ) is a self-contained software stack. As Singularity does not require a root-level daemon to run its images (as is required by Docker) it is suitable for use on multi-user HPC systems such as ARCHER2. Within the container/image, you have exactly the same permissions as you do in a standard login session on the system. In practice, this means that an image created on your local machine with all your research software installed for local development will also run on ARCHER2. Pre-built images (such as those on DockerHub or SingularityHub ) can simply be downloaded and used on ARCHER2 (or anywhere else Singularity is installed); see use_image_singularity ). Creating and modifying images requires root permission and so must be done on a system where you have such access (in practice, this is usually within a virtual machine on your laptop/workstation); see create_image_singularity . Using Singularity Images on ARCHER2 Singularity images can be used on ARCHER2 in a number of ways, including: Interactively on the login nodes Interactively on compute nodes As serial processes within a non-interactive batch script As parallel processes within a non-interactive batch script (not yet documented) We provide information on each of these scenarios (apart from the parallel use where we are still preparing the documentation) below. First, we describe briefly how to get existing images onto ARCHER2 so you can use them. Getting existing images onto ARCHER2 Singularity images are simply files, so, if you already have an image file, you can use scp to copy the file to ARCHER2 as you would with any other file. If you wish to get a file from one of the container image repositories then Singularity allows you to do this from ARCHER2 itself. This functionality requires tools that are not part of the standard OS on ARCHER2 so we have provided a Singularity image that allows you to build images from remote repositories (i.e. you use a Singularity image to build Singularity images!). For example, to retrieve an image from DockerHub on ARCHER2 we fist need to enter an interactive session in the image we provide for building Singularity images: [user@archer2-login0 ~]$ module load singularity [user@archer2-login0 ~]$ singularity exec $CIRRUS_SIMG/archer2-sbuild.simg /bin/bash --login Singularity> This invokes a login bash shell within the $CIRRUS_SIMG/archer2-sbuild.simg image as indicated by our prompt change. (We need a login shell to allow module commands to work within the image.) Now we are in the image we can load the singularity module (to get access to the Singularity commands) and pull an image from DockerHub: Singularity> module load singularity Singularity> singularity build lolcow.simg docker://godlovedc/lolcow Docker image path: index.docker.io/godlovedc/lolcow:latest Cache folder set to /lustre/home/t01/user/.singularity/docker Importing: base Singularity environment Importing: /lustre/home/t01/user/.singularity/docker/sha256:9fb6c798fa41e509b58bccc5c29654c3ff4648b608f5daa67c1aab6a7d02c118.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:3b61febd4aefe982e0cb9c696d415137384d1a01052b50a85aae46439e15e49a.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:9d99b9777eb02b8943c0e72d7a7baec5c782f8fd976825c9d3fb48b3101aacc2.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:d010c8cf75d7eb5d2504d5ffa0d19696e8d745a457dd8d28ec6dd41d3763617e.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:7fac07fb303e0589b9c23e6f49d5dc1ff9d6f3c8c88cabe768b430bdb47f03a9.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:8e860504ff1ee5dc7953672d128ce1e4aa4d8e3716eb39fe710b849c64b20945.tar.gz Importing: /lustre/home/t01/user/.singularity/metadata/sha256:ab22e7ef68858b31e1716fa2eb0d3edec81ae69c6b235508d116a09fc7908cff.tar.gz WARNING: Building container as an unprivileged user. If you run this container as root WARNING: it may be missing some functionality. Building Singularity image... Singularity container built: lolcow.simg Cleaning up... The first argument to the singularity build command ( lolcow.simg ) specifies a path and name for your container. The second argument ( docker://godlovedc/lolcow ) gives the DockerHub URI from which to download the image. Now we can exit the archer2-sbuild image and run the new lolcow image that we have just built on the ARCHER2 login node: [user@archer2-login0 ~]$ singularity run lolcow.simg This image contains a runscript that tells Singularity what to do if we run the image. We demonstrate different ways to use images below. Similar syntax can be used for Singularity Hub. For more information see the Singularity documentation: Build a Container Interactive use on the login nodes Once you have an image file, using it on the login nodes in an interactive way is extremely simple: you use the singularity shell command. Using the image we built in the example above: [user@archer2-login0 ~]$ module load singularity [user@archer2-login0 ~]$ singularity shell lolcow.simg Singularity: Invoking an interactive shell within container... Singularity lolcow.simg:~> Within a Singularity image your home directory will be available. The directory with centrally-installed software ( /lustre/sw ) is also available in images by default. Note that the module command will not work in images unless you have installed the required software and configured the environment correctly; we describe how to do this below. Once you have finished using your image, you can return to the ARCHER2 login node command line with the exit command: Singularity lolcow.simg:~> exit exit [user@archer2-login0 ~]$ Interactive use on the compute nodes The process for using an image interactively on the compute nodes is very similar to that for using them on the login nodes. The only difference is that you have to submit an interactive serial job to get interactive access to the compute node first. For example, to reserve a full node for you to work on interactively you would use: [user@archer2-login0 ~]$ qsub -IVl select=1:ncpus=36,walltime=0:20:0,place=scatter:excl -A t01 qsub: waiting for job 234192.indy2-login0 to start ...wait until job starts... qsub: job 234192.indy2-login0 ready [user@r1i2n13 ~]$ Note that the prompt has changed to show you are on a compute node. Now you can use the image in the same way as on the login node. [user@r1i2n13 ~]$ module load singularity [user@r1i2n13 ~]$ singularity shell lolcow.simg Singularity: Invoking an interactive shell within container... Singularity lolcow.simg:~> exit exit [user@r1i2n13 ~]$ exit [user@archer2-login0 ~]$ Note how we used exit to leave the interactive image shell and then exit again to leave the interactive job on the compute node. Serial processes within a non-interactive batch script You can also use Singularity images within a non-interactive batch script as you would any other command. If your image contains a runscript then you can use singularity run to execute the runscript in the job. You can also use singularity exec to execute arbitrary commands (or scripts) within the image. An example job submission script to run a serial job that executes the runscript within the lolcow.simg image that we built previously on an ARCHER2 login node would be as follows. #!/bin/bash --login # Slurm job options (name, compute nodes, job time) #SBATCH -J simgtest #SBATCH -o simgtest.o%j #SBATCH -e simgtest.o%j #SBATCH -p [partition] #SBATCH -A [budget code] #SBATCH --nodes=1 #SBATCH --ntasks=1 #SBATCH --time=00:10:00 # Change to the directory that the job was submitted from cd $HOME # Load any required modules module load singularity # Run the serial executable singularity run $HOME/lolcow.simg You submit this in the usual way and the standard output and error should be written to simgtest.o... , where the output filename ends with the job number. Parallel processes within a non-interactive batch script Running a Singularity image within a parallel batch script is somewhat more involved. Let's assume that the lolcow image contains an executable of the same name whose path is /opt/apps/lolcow . And we will also assume that the image contains an installation of a specific MPI library, openmpi v4.0.3 in this case. Please note, the MPI library contained in the image must match the MPI library on the host. In practice, the MPI library used on the host and within the container must have the same vendor (e.g., MPICH, openmpi, Intel MPI) and the same version number (although, in some situations it might be possible to have different minor version numbers). Below is an example job submission script that runs a Singularity container over four nodes. #!/bin/bash --login # Slurm job options (name, compute nodes, job time) #SBATCH -J simgtest #SBATCH -o simgtest.o%j #SBATCH -e simgtest.o%j #SBATCH -p [partition] #SBATCH -A [budget code] #SBATCH --nodes=4 #SBATCH --ntasks=256 #SBATCH --time=01:10:00 # setup resource-related environment NNODES=$SLURM_JOB_NUM_NODES NCORESPN=$SLURM_CPUS_ON_NODE NCORES=`expr ${NNODES} \\* ${NCORESPN}` export OMP_NUM_THREADS=1 # setup local openmpi installation (env.sh exports OPENMPI_ROOT) . $HOME/opt/openmpi-4.0.3/dist/env.sh # Change to the directory that contains lolcow.simg and lolcow.in cd $HOME # Load any required modules module load singularity RUN_START=$(date +%s.%N) MPIRUN_PREFIX_OPT=\"--prefix ${OPENMPI_ROOT}\" MPIRUN_RES_OPTS=\"-N ${NCORESPN} -n ${NCORES} --hostfile ${HOME}/hosts --bind-to core\" MPIRUN_MCA_OPTS=\"--mca btl ^sm --mca btl_openib_allow_ib true\" MPIRUN_OPTS=\"${MPIRUN_PREFIX_OPT} ${MPIRUN_RES_OPTS} ${MPIRUN_MCA_OPTS}\" SINGULARITY_OPTS=\"exec -B /etc/libibverbs.d\" mpirun $MPIRUN_OPTS singularity $SINGULARITY_OPTS $HOME/lolcow.simg /opt/apps/lolcow $HOME/lolcow.in &> $HOME/lolcow.out RUN_STOP=$(date +%s.%N) RUN_TIME=$(echo \"${RUN_STOP} - ${RUN_START}\" | bc) echo \"mpirun time: ${RUN_TIME}\" >> $HOME/lolcow.out The key line in the submission script above is the mpirun command; it can be thought of as three nested commands. The innermost command is the one that calls the lolcow executable, /opt/apps/lolcow $HOME/lolcow.in &> $HOME/lolcow.out . Note how the lolcow exe is in the container whereas the input and output files are on the host. The lolcow command is passed to Singularity, e.g., singularity exec -B /etc/libibverbs.d ... ; use of the exec option allows us to run an arbitrary command within the container. The -B option creates an identical config directory within the container that is bound to the same path on the host. (The term \"verbs\" is used to denote the interface to the Infiniband hardware interconnect.) Lastly, the Singularity command is passed to the parallel job launcher, mpirun in this case. It's at this point that we specify the number of hardware resources used to run the container. Creating Your Own Singularity Images As we saw above, you can create Singularity images by importing from DockerHub or Singularity Hub on ARCHER2 itself. If you wish to create your own custom image then you must install Singularity on a system where you have root (or administrator) privileges - often your own laptop or workstation. We provide links below to instructions on how to install Singularity locally and then cover what options you need to include in a Singularity recipe file to create images that can run on ARCHER2 and access the software development modules. (This can be useful if you want to create a custom environment but still want to compile and link against libraries that you only have access to on ARCHER2 such as the Intel compilers, HPE MPI libraries, etc.) Installing Singularity on Your Local Machine You will need Singularity installed on your machine in order to locally run, create and modify images. How you install Singularity on your laptop/workstation depends on the operating system you are using. If you are using Windows or macOS, the simplest solution is to use Vagrant to give you an easy to use virtual environment with Linux and Singularity installed. The Singularity website has instructions on how to use this method to install Singularity: Installing Singularity on macOS with Vagrant Installing Singularity on Windows with Vagrant If you are using Linux then you can usually install Singularity directly, see: Installing Singularity on Linux Singularity Recipes to Access modules on ARCHER2 You may want your custom image to be able to access the modules environment on ARCHER2 so you can make use of custom software that you cannot access elsewhere. We demonstrate how to do this for a CentOS 7 image but the steps are easily translated for other flavours of Linux. For the ARCHER2 modules to be available in your Singularity container you need to ensure that the environment-modules package is installed in your image. In addition, when you use the container you must invoke access as a login shell to have access to the module commands. Here is an example recipe file to build a CentOS 7 image with access to TCL modules alread installed on ARCHER2: BootStrap: docker From: centos:centos7 %post yum update -y yum install environment-modules -y If we save this recipe to a file called archer2-mods.def then we can use the following command to build this image (remember this command must be run on a system where you have root access, not ARCHER2): me@my-system:~> sudo singularity build archer2-mods.simg archer2-mods.def The resulting image file ( archer2-mods.simg ) can then be compied to ARCHER2 using scp. When you use the image interactively on ARCHER2 you must start with a login shell, i.e.: [user@archer2-login0 ~]$ module load singularity [user@archer2-login0 ~]$ singularity exec archer2-mods.simg /bin/bash --login Singularity> module avail intel-compilers ------------------------- /lustre/sw/modulefiles --------------------- intel-compilers-16/16.0.2.181 intel-compilers-16/16.0.3.210(default) intel-compilers-17/17.0.2.174(default)","title":"Containers"},{"location":"user-guide/containers/#containers","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. This page was originally based on the documentation at the University of Sheffield HPC service <http://docs.hpc.shef.ac.uk/en/latest/sharc/software/apps/singularity.html> . Designed around the notion of mobility of compute and reproducible science, Singularity enables users to have full control of their operating system environment. This means that a non-privileged user can \"swap out\" the Linux operating system and environment on the host for a Linux OS and environment that they control. So if the host system is running CentOS Linux but your application runs in Ubuntu Linux with a particular software stack; you can create an Ubuntu image, install your software into that image, copy the image to another host (e.g. ARCHER2), and run your application on that host in it\u2019s native Ubuntu environment. Singularity also allows you to leverage the resources of whatever host you are on. This includes high-speed interconnects (i.e. Infinband on ARCHER2), file systems (i.e. /lustre on ARCHER2) and potentially other resources (e.g. the licensed Intel compilers on ARCHER2). Note: Singularity only supports Linux containers. You cannot create images that use Windows or macOS (this is a restriction of the containerisation model rather than Singularity).","title":"Containers"},{"location":"user-guide/containers/#useful-links","text":"Singularity website Singularity documentation","title":"Useful Links"},{"location":"user-guide/containers/#about-singularity-containers-images","text":"Similar to Docker, a Singularity container (or, more commonly, image ) is a self-contained software stack. As Singularity does not require a root-level daemon to run its images (as is required by Docker) it is suitable for use on multi-user HPC systems such as ARCHER2. Within the container/image, you have exactly the same permissions as you do in a standard login session on the system. In practice, this means that an image created on your local machine with all your research software installed for local development will also run on ARCHER2. Pre-built images (such as those on DockerHub or SingularityHub ) can simply be downloaded and used on ARCHER2 (or anywhere else Singularity is installed); see use_image_singularity ). Creating and modifying images requires root permission and so must be done on a system where you have such access (in practice, this is usually within a virtual machine on your laptop/workstation); see create_image_singularity .","title":"About Singularity Containers (Images)"},{"location":"user-guide/containers/#using-singularity-images-on-archer2","text":"Singularity images can be used on ARCHER2 in a number of ways, including: Interactively on the login nodes Interactively on compute nodes As serial processes within a non-interactive batch script As parallel processes within a non-interactive batch script (not yet documented) We provide information on each of these scenarios (apart from the parallel use where we are still preparing the documentation) below. First, we describe briefly how to get existing images onto ARCHER2 so you can use them.","title":"Using Singularity Images on ARCHER2"},{"location":"user-guide/containers/#getting-existing-images-onto-archer2","text":"Singularity images are simply files, so, if you already have an image file, you can use scp to copy the file to ARCHER2 as you would with any other file. If you wish to get a file from one of the container image repositories then Singularity allows you to do this from ARCHER2 itself. This functionality requires tools that are not part of the standard OS on ARCHER2 so we have provided a Singularity image that allows you to build images from remote repositories (i.e. you use a Singularity image to build Singularity images!). For example, to retrieve an image from DockerHub on ARCHER2 we fist need to enter an interactive session in the image we provide for building Singularity images: [user@archer2-login0 ~]$ module load singularity [user@archer2-login0 ~]$ singularity exec $CIRRUS_SIMG/archer2-sbuild.simg /bin/bash --login Singularity> This invokes a login bash shell within the $CIRRUS_SIMG/archer2-sbuild.simg image as indicated by our prompt change. (We need a login shell to allow module commands to work within the image.) Now we are in the image we can load the singularity module (to get access to the Singularity commands) and pull an image from DockerHub: Singularity> module load singularity Singularity> singularity build lolcow.simg docker://godlovedc/lolcow Docker image path: index.docker.io/godlovedc/lolcow:latest Cache folder set to /lustre/home/t01/user/.singularity/docker Importing: base Singularity environment Importing: /lustre/home/t01/user/.singularity/docker/sha256:9fb6c798fa41e509b58bccc5c29654c3ff4648b608f5daa67c1aab6a7d02c118.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:3b61febd4aefe982e0cb9c696d415137384d1a01052b50a85aae46439e15e49a.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:9d99b9777eb02b8943c0e72d7a7baec5c782f8fd976825c9d3fb48b3101aacc2.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:d010c8cf75d7eb5d2504d5ffa0d19696e8d745a457dd8d28ec6dd41d3763617e.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:7fac07fb303e0589b9c23e6f49d5dc1ff9d6f3c8c88cabe768b430bdb47f03a9.tar.gz Importing: /lustre/home/t01/user/.singularity/docker/sha256:8e860504ff1ee5dc7953672d128ce1e4aa4d8e3716eb39fe710b849c64b20945.tar.gz Importing: /lustre/home/t01/user/.singularity/metadata/sha256:ab22e7ef68858b31e1716fa2eb0d3edec81ae69c6b235508d116a09fc7908cff.tar.gz WARNING: Building container as an unprivileged user. If you run this container as root WARNING: it may be missing some functionality. Building Singularity image... Singularity container built: lolcow.simg Cleaning up... The first argument to the singularity build command ( lolcow.simg ) specifies a path and name for your container. The second argument ( docker://godlovedc/lolcow ) gives the DockerHub URI from which to download the image. Now we can exit the archer2-sbuild image and run the new lolcow image that we have just built on the ARCHER2 login node: [user@archer2-login0 ~]$ singularity run lolcow.simg This image contains a runscript that tells Singularity what to do if we run the image. We demonstrate different ways to use images below. Similar syntax can be used for Singularity Hub. For more information see the Singularity documentation: Build a Container","title":"Getting existing images onto ARCHER2"},{"location":"user-guide/containers/#interactive-use-on-the-login-nodes","text":"Once you have an image file, using it on the login nodes in an interactive way is extremely simple: you use the singularity shell command. Using the image we built in the example above: [user@archer2-login0 ~]$ module load singularity [user@archer2-login0 ~]$ singularity shell lolcow.simg Singularity: Invoking an interactive shell within container... Singularity lolcow.simg:~> Within a Singularity image your home directory will be available. The directory with centrally-installed software ( /lustre/sw ) is also available in images by default. Note that the module command will not work in images unless you have installed the required software and configured the environment correctly; we describe how to do this below. Once you have finished using your image, you can return to the ARCHER2 login node command line with the exit command: Singularity lolcow.simg:~> exit exit [user@archer2-login0 ~]$","title":"Interactive use on the login nodes"},{"location":"user-guide/containers/#interactive-use-on-the-compute-nodes","text":"The process for using an image interactively on the compute nodes is very similar to that for using them on the login nodes. The only difference is that you have to submit an interactive serial job to get interactive access to the compute node first. For example, to reserve a full node for you to work on interactively you would use: [user@archer2-login0 ~]$ qsub -IVl select=1:ncpus=36,walltime=0:20:0,place=scatter:excl -A t01 qsub: waiting for job 234192.indy2-login0 to start ...wait until job starts... qsub: job 234192.indy2-login0 ready [user@r1i2n13 ~]$ Note that the prompt has changed to show you are on a compute node. Now you can use the image in the same way as on the login node. [user@r1i2n13 ~]$ module load singularity [user@r1i2n13 ~]$ singularity shell lolcow.simg Singularity: Invoking an interactive shell within container... Singularity lolcow.simg:~> exit exit [user@r1i2n13 ~]$ exit [user@archer2-login0 ~]$ Note how we used exit to leave the interactive image shell and then exit again to leave the interactive job on the compute node.","title":"Interactive use on the compute nodes"},{"location":"user-guide/containers/#serial-processes-within-a-non-interactive-batch-script","text":"You can also use Singularity images within a non-interactive batch script as you would any other command. If your image contains a runscript then you can use singularity run to execute the runscript in the job. You can also use singularity exec to execute arbitrary commands (or scripts) within the image. An example job submission script to run a serial job that executes the runscript within the lolcow.simg image that we built previously on an ARCHER2 login node would be as follows. #!/bin/bash --login # Slurm job options (name, compute nodes, job time) #SBATCH -J simgtest #SBATCH -o simgtest.o%j #SBATCH -e simgtest.o%j #SBATCH -p [partition] #SBATCH -A [budget code] #SBATCH --nodes=1 #SBATCH --ntasks=1 #SBATCH --time=00:10:00 # Change to the directory that the job was submitted from cd $HOME # Load any required modules module load singularity # Run the serial executable singularity run $HOME/lolcow.simg You submit this in the usual way and the standard output and error should be written to simgtest.o... , where the output filename ends with the job number.","title":"Serial processes within a non-interactive batch script"},{"location":"user-guide/containers/#parallel-processes-within-a-non-interactive-batch-script","text":"Running a Singularity image within a parallel batch script is somewhat more involved. Let's assume that the lolcow image contains an executable of the same name whose path is /opt/apps/lolcow . And we will also assume that the image contains an installation of a specific MPI library, openmpi v4.0.3 in this case. Please note, the MPI library contained in the image must match the MPI library on the host. In practice, the MPI library used on the host and within the container must have the same vendor (e.g., MPICH, openmpi, Intel MPI) and the same version number (although, in some situations it might be possible to have different minor version numbers). Below is an example job submission script that runs a Singularity container over four nodes. #!/bin/bash --login # Slurm job options (name, compute nodes, job time) #SBATCH -J simgtest #SBATCH -o simgtest.o%j #SBATCH -e simgtest.o%j #SBATCH -p [partition] #SBATCH -A [budget code] #SBATCH --nodes=4 #SBATCH --ntasks=256 #SBATCH --time=01:10:00 # setup resource-related environment NNODES=$SLURM_JOB_NUM_NODES NCORESPN=$SLURM_CPUS_ON_NODE NCORES=`expr ${NNODES} \\* ${NCORESPN}` export OMP_NUM_THREADS=1 # setup local openmpi installation (env.sh exports OPENMPI_ROOT) . $HOME/opt/openmpi-4.0.3/dist/env.sh # Change to the directory that contains lolcow.simg and lolcow.in cd $HOME # Load any required modules module load singularity RUN_START=$(date +%s.%N) MPIRUN_PREFIX_OPT=\"--prefix ${OPENMPI_ROOT}\" MPIRUN_RES_OPTS=\"-N ${NCORESPN} -n ${NCORES} --hostfile ${HOME}/hosts --bind-to core\" MPIRUN_MCA_OPTS=\"--mca btl ^sm --mca btl_openib_allow_ib true\" MPIRUN_OPTS=\"${MPIRUN_PREFIX_OPT} ${MPIRUN_RES_OPTS} ${MPIRUN_MCA_OPTS}\" SINGULARITY_OPTS=\"exec -B /etc/libibverbs.d\" mpirun $MPIRUN_OPTS singularity $SINGULARITY_OPTS $HOME/lolcow.simg /opt/apps/lolcow $HOME/lolcow.in &> $HOME/lolcow.out RUN_STOP=$(date +%s.%N) RUN_TIME=$(echo \"${RUN_STOP} - ${RUN_START}\" | bc) echo \"mpirun time: ${RUN_TIME}\" >> $HOME/lolcow.out The key line in the submission script above is the mpirun command; it can be thought of as three nested commands. The innermost command is the one that calls the lolcow executable, /opt/apps/lolcow $HOME/lolcow.in &> $HOME/lolcow.out . Note how the lolcow exe is in the container whereas the input and output files are on the host. The lolcow command is passed to Singularity, e.g., singularity exec -B /etc/libibverbs.d ... ; use of the exec option allows us to run an arbitrary command within the container. The -B option creates an identical config directory within the container that is bound to the same path on the host. (The term \"verbs\" is used to denote the interface to the Infiniband hardware interconnect.) Lastly, the Singularity command is passed to the parallel job launcher, mpirun in this case. It's at this point that we specify the number of hardware resources used to run the container.","title":"Parallel processes within a non-interactive batch script"},{"location":"user-guide/containers/#creating-your-own-singularity-images","text":"As we saw above, you can create Singularity images by importing from DockerHub or Singularity Hub on ARCHER2 itself. If you wish to create your own custom image then you must install Singularity on a system where you have root (or administrator) privileges - often your own laptop or workstation. We provide links below to instructions on how to install Singularity locally and then cover what options you need to include in a Singularity recipe file to create images that can run on ARCHER2 and access the software development modules. (This can be useful if you want to create a custom environment but still want to compile and link against libraries that you only have access to on ARCHER2 such as the Intel compilers, HPE MPI libraries, etc.)","title":"Creating Your Own Singularity Images"},{"location":"user-guide/containers/#installing-singularity-on-your-local-machine","text":"You will need Singularity installed on your machine in order to locally run, create and modify images. How you install Singularity on your laptop/workstation depends on the operating system you are using. If you are using Windows or macOS, the simplest solution is to use Vagrant to give you an easy to use virtual environment with Linux and Singularity installed. The Singularity website has instructions on how to use this method to install Singularity: Installing Singularity on macOS with Vagrant Installing Singularity on Windows with Vagrant If you are using Linux then you can usually install Singularity directly, see: Installing Singularity on Linux","title":"Installing Singularity on Your Local Machine"},{"location":"user-guide/containers/#singularity-recipes-to-access-modules-on-archer2","text":"You may want your custom image to be able to access the modules environment on ARCHER2 so you can make use of custom software that you cannot access elsewhere. We demonstrate how to do this for a CentOS 7 image but the steps are easily translated for other flavours of Linux. For the ARCHER2 modules to be available in your Singularity container you need to ensure that the environment-modules package is installed in your image. In addition, when you use the container you must invoke access as a login shell to have access to the module commands. Here is an example recipe file to build a CentOS 7 image with access to TCL modules alread installed on ARCHER2: BootStrap: docker From: centos:centos7 %post yum update -y yum install environment-modules -y If we save this recipe to a file called archer2-mods.def then we can use the following command to build this image (remember this command must be run on a system where you have root access, not ARCHER2): me@my-system:~> sudo singularity build archer2-mods.simg archer2-mods.def The resulting image file ( archer2-mods.simg ) can then be compied to ARCHER2 using scp. When you use the image interactively on ARCHER2 you must start with a login shell, i.e.: [user@archer2-login0 ~]$ module load singularity [user@archer2-login0 ~]$ singularity exec archer2-mods.simg /bin/bash --login Singularity> module avail intel-compilers ------------------------- /lustre/sw/modulefiles --------------------- intel-compilers-16/16.0.2.181 intel-compilers-16/16.0.3.210(default) intel-compilers-17/17.0.2.174(default)","title":"Singularity Recipes to Access modules on ARCHER2"},{"location":"user-guide/data/","text":"Data management and transfer Warning The ARCHER2 Service is not yet available. This documentation is in development. This section covers best practice and tools for data management on ARCHER2. Note If you have any questions on data management and transfer please do not hesitate to contact the ARCHER2 service desk at support@archer2.ac.uk . Useful resources and links Harry Mangalam's guide on How to transfer large amounts of data via network . This provides lots of useful advice on transferring data though we now recommend using Globus Online, rather than GridFTP directly. Data management We strongly recommend that you give some thought to how you use the various data storage facilities that are part of the ARCHER2 service. This will not only allow you to use the machine more effectively but also to ensure that your valuable data is protected. ARCHER2 storage The ARCHER2 service, like many HPC systems has a complex structure. There are a number of different data storage types available to users: Home file systems Work file systems Solid state storage RDF storage Each type of storage has different characteristics and policies, and is suitable for different types of use. There are also many different types of node available to users: Login nodes Compute nodes Data analysis and pre-/post-processing nodes Data transfer nodes Each type of node sees a different combination of the storage types. Home file systems There are four independent home file-systems. Every project has an allocation on one of the four. You do not need to know which one your project uses as your projects space can always be accessed via the path /home/project-code . Each home file-system is approximately 60TB in size and is implemented using standard Network Attached Storage (NAS) technology. This means that these disks are not particularly high performance but are well suited to standard operations like compilation and file editing. These file systems are visible from the ARCHER2 login nodes and the pre-/post-processing nodes. The home file systems are fully backed up . Full backups are taken weekly with incremental backups added every day in between. Backups are kept for disaster recovery purposes only. If you have accidentally lost data from a backed-up file-system and have no other way of recovering the data then contact us as quickly as possible but we may be unable to assist. These file-systems are a good location to keep source-code, copies of scripts and compiled binaries. Small amounts of important data can also be copied here for safe keeping though the file systems are not fast enough to manipulate large datasets effectively. Warning Files with filenames that contain non-ascii characters and/or non-printable characters cannot be backed up using our automated process and so will be omitted from all backups. Work file systems There are three independent work file-systems: /fs2 1.5PB /fs3 1.5PB /fs4 1.8PB Every project has an allocation on one of the three. You do not need to know which one your project uses as your projects space can always be accessed via the path /work/project-code . These are high-performance, Lustre parallel file systems. They are designed to support data in large files. The performance for data stored in large numbers of small files is probably not going to be as good. These are the only file systems that are available on the compute nodes so all data read or written by jobs running on the compute nodes has to be hosted here. Warning There are no backups of any data on the work file systems. You should not rely on these file systems for long term storage. Ideally, these file systems should only contain data that is: actively in use; recently generated and in the process of being saved elsewhere; or being made ready for up-coming work. In practice it may be convenient to keep copies of datasets on the work file systems that you know will be needed at a later date. However, make sure that important data is always backed up elsewhere and that your work would not be significantly impacted if the data on the work file systems was lost. Large data sets can be copied to the RDF storage or transferred off the ARCHER2 service entirely. If you have data on the work file systems that you are not going to need in the future please delete it. Solid state storage RDF storage Archiving and data transfer Data transfer speed may be limited by many different factors so the best data transfer mechanism to use depends on the type of data being transferred and where the data is going. Disk speed - The ARCHER2 /work file-systems and the RDF file-systems are highly parallel consisting of a very large number of high performance disk drives. This allows them to support a very high data bandwidth. Unless the remote system has a similar parallel file-system you may find your transfer speed limited by disk performance. Meta-data performance - Meta-data operations such as opening and closing files or listing the owner or size of a file are much less parallel than read/write operations. If your data consists of a very large number of small files you may find your transfer speed is limited by meta-data operations. Meta-data operations performed by other users of the system will interact strongly with those you perform so reducing the number of such operations you use, may reduce variability in your IO timings. Network speed - Data transfer performance can be limited by network speed. More importantly it is limited by the slowest section of the network between source and destination. Firewall speed - Most modern networks are protected by some form of firewall that filters out malicious traffic. This filtering has some overhead and can result in a reduction in data transfer performance. The needs of a general purpose network that hosts email/web-servers and desktop machines are quite different from a research network that needs to support high volume data transfers. If you are trying to transfer data to or from a host on a general purpose network you may find the firewall for that network will limit the transfer rate you can achieve. The method you use to transfer data to/from ARCHER2 will depend on how much you want to transfer and where to. The methods we cover in this guide are: scp/sftp/rsync - These are the simplest methods of transferring data and can be used up to moderate amounts of data. If you are transferring data to your workstation/laptop then this is the method you will use. Globus Online (GO) - If you are transferring large amounts of data to another central computing facility then GO provides high performance parallel data transfer functionality. Both ends of the transfer must be setup as GO endpoints (ARCHER2 is configured as a GO endpoint. Before discussing specific data transfer methods, we cover archiving which is an essential process for transferring data efficiently. Archiving If you have related data that consists of a large number of small files it is strongly recommended to pack the files into a larger \"archive\" file for ease of transfer and manipulation. A single large file makes more efficient use of the file system and is easier to move and copy and transfer because significantly fewer meta-data operations are required. Archive files can be created using tools like tar and zip . tar The tar command packs files into a \"tape archive\" format. The command has general form: tar [options] [file(s)] Common options include: -c create a new archive -v verbosely list files processed -W verify the archive after writing -l confirm all file hard links are included in the archive -f use an archive file (for historical reasons, tar writes its output to stdout by default rather than a file). Putting these together: tar -cvWlf mydata.tar mydata will create and verify an archive. To extract files from a tar file, the option -x is used. For example: tar -xf mydata.tar will recover the contents of mydata.tar to the current working directory. To verify an existing tar file against a set of data, the -d (diff) option can be used. By default, no output will be given if a verification succeeds and an example of a failed verification follows: $> tar -df mydata.tar mydata/* mydata/damaged_file: Mod time differs mydata/damaged_file: Size differs Note that tar files do not store checksums with their data, requiring the original data to be present during verification. Further information on using tar can be found in the tar manual (accessed via man tar or at man tar ). zip The zip file format is widely used for archiving files and is supported by most major operating systems. The utility to create zip files can be run from the command line as: zip [options] mydata.zip [file(s)] Common options are: -r used to zip up a directory -# where \"#\" represents a digit ranging from 0 to 9 to specify compression level, 0 being the least and 9 the most. Default compression is -6 but we recommend using -0 to speed up the archiving process. Together: zip -0r mydata.zip mydata will create an archive. Note Unlike tar, zip files do not preserve hard links. File data will be copied on archive creation, e.g. an uncompressed zip archive of a 100MB file and a hard link to that file will be approximately 200MB in size. This makes zip an unsuitable format if you wish to precisely reproduce the file system layout. The corresponding unzip command is used to extract data from the archive. The simplest use case is: unzip mydata.zip which recovers the contents of the archive to the current working directory. Files in a zip archive are stored with a CRC checksum to help detect data loss. unzip provides options for verifying this checksum against the stored files. The relevant flag is -t and is used as follows: $> unzip -t mydata.zip Archive: mydata.zip testing: mydata/ OK testing: mydata/file OK No errors detected in compressed data of mydata.zip. Further information on using zip can be found in the zip manual (accessed via man zip or at man zip ). Data transfer via SSH The easiest way of transferring data to/from ARCHER2 is to use one of the standard programs based on the SSH protocol such as scp , sftp or rsync . These all use the same underlying mechanism (SSH) as you normally use to log-in to ARCHER2. So, once the the command has been executed via the command line, you will be prompted for your password for the specified account on the remote machine (ARCHER2 in this case). To avoid having to type in your password multiple times you can set up a SSH key pair and use an SSH agent as documented in the User Guide at connecting . SSH data transfer performance considerations The SSH protocol encrypts all traffic it sends. This means that file transfer using SSH consumes a relatively large amount of CPU time at both ends of the transfer (for encryption and decryption). The ARCHER2 login nodes have fairly fast processors that can sustain about 100 MB/s transfer. The encryption algorithm used is negotiated between the SSH client and the SSH server. There are command line flags that allow you to specify a preference for which encryption algorithm should be used. You may be able to improve transfer speeds by requesting a different algorithm than the default. The aes128-ctr or aes256-ctr algorithms are well supported and fast as they are implemented in hardware. Note: these are not usually the default choice when using scp so you will need to manually specify them. A single SSH based transfer will usually not be able to saturate the available network bandwidth or the available disk bandwidth so you may see an overall improvement by running several data transfer operations in parallel. To reduce metadata interactions it is a good idea to overlap transfers of files from different directories. In addition, you should consider the following when transferring data: Only transfer those files that are required. Consider which data you really need to keep. Combine lots of small files into a single tar archive, to reduce the overheads associated in initiating many separate data transfers (over SSH, each file counts as an individual transfer). Compress data before transferring it, e.g. using gzip . scp The scp command creates a copy of a file, or if given the -r flag, a directory either from a local machine onto a remote machine or from a remote machine onto a local machine. For example, to transfer files to ARCHER2 from a local machine: scp [options] source user@login.archer2.ac.uk:[destination] (Remember to replace user with your ARCHER2 username in the example above.) In the above example, the [destination] is optional, as when left out scp will copy the source into your home directory. Also, the source should be the absolute path of the file/directory being copied or the command should be executed in the directory containing the source file/directory. If you want to request a different encryption algorithm add the -c [algorithm-name] flag to the scp options. For example, to use the (usually faster) arcfour encryption algorithm you would use: scp [options] -c aes128-ctr source user@login.archer2.ac.uk:[destination] (Remember to replace user with your ARCHER2 username in the example above.) rsync The rsync command can also transfer data between hosts using a ssh connection. It creates a copy of a file or, if given the -r flag, a directory at the given destination, similar to scp above. Given the -a option rsync can also make exact copies (including permissions), this is referred to as mirroring . In this case the rsync command is executed with ssh to create the copy on a remote machine. To transfer files to ARCHER2 using rsync with ssh the command has the form: rsync [options] -e ssh source user@login.archer2.ac.uk:[destination] (Remember to replace user with your ARCHER2 username in the example above.) In the above example, the [destination] is optional, as when left out rsync will copy the source into your home directory. Also the source should be the absolute path of the file/directory being copied or the command should be executed in the directory containing the source file/directory. Additional flags can be specified for the underlying ssh command by using a quoted string as the argument of the -e flag. e.g. rsync [options] -e \"ssh -c arcfour\" source user@login.archer2.ac.uk:[destination] (Remember to replace user with your ARCHER2 username in the example above.) Further information on using rsync can be found in the rsync manual (accessed via man rsync or at man rsync ). Globus online (GO) Globus online is a web-based file transfer portal provided by the Globus project: www.globus.org You will need to register with the web portal and create an account before you can use GO. Internally, GO uses the GridFTP file transfer mechanism but the web portal provides a simple user interface and handles all the management of file transfers. GO will retry failed transfers and send notifications when transfers complete so there is no need to stay logged into the web portal while transfers are ongoing. To transfer data between sites, both ends of the transfer need to support a GO endpoint . GO also provide a client you can install on your laptop or workstation that can act as a local endpoint (though you often do not have a network connection with sufficient bandwidth from your local system to support high performance data transfers). You have to activate an endpoint before use, either by enabling the connector software on your local machine or by providing login details in your browser for a server endpoint. Once activated, endpoints will remain active for a couple of days allowing transfers to complete. The GO endpoint on ARCHER2 is called \"ARCHER2\". When activating this endpoint use the same username and password you use to login to ARCHER2.","title":"Data"},{"location":"user-guide/data/#data-management-and-transfer","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. This section covers best practice and tools for data management on ARCHER2. Note If you have any questions on data management and transfer please do not hesitate to contact the ARCHER2 service desk at support@archer2.ac.uk .","title":"Data management and transfer"},{"location":"user-guide/data/#useful-resources-and-links","text":"Harry Mangalam's guide on How to transfer large amounts of data via network . This provides lots of useful advice on transferring data though we now recommend using Globus Online, rather than GridFTP directly.","title":"Useful resources and links"},{"location":"user-guide/data/#data-management","text":"We strongly recommend that you give some thought to how you use the various data storage facilities that are part of the ARCHER2 service. This will not only allow you to use the machine more effectively but also to ensure that your valuable data is protected.","title":"Data management"},{"location":"user-guide/data/#archer2-storage","text":"The ARCHER2 service, like many HPC systems has a complex structure. There are a number of different data storage types available to users: Home file systems Work file systems Solid state storage RDF storage Each type of storage has different characteristics and policies, and is suitable for different types of use. There are also many different types of node available to users: Login nodes Compute nodes Data analysis and pre-/post-processing nodes Data transfer nodes Each type of node sees a different combination of the storage types.","title":"ARCHER2 storage"},{"location":"user-guide/data/#home-file-systems","text":"There are four independent home file-systems. Every project has an allocation on one of the four. You do not need to know which one your project uses as your projects space can always be accessed via the path /home/project-code . Each home file-system is approximately 60TB in size and is implemented using standard Network Attached Storage (NAS) technology. This means that these disks are not particularly high performance but are well suited to standard operations like compilation and file editing. These file systems are visible from the ARCHER2 login nodes and the pre-/post-processing nodes. The home file systems are fully backed up . Full backups are taken weekly with incremental backups added every day in between. Backups are kept for disaster recovery purposes only. If you have accidentally lost data from a backed-up file-system and have no other way of recovering the data then contact us as quickly as possible but we may be unable to assist. These file-systems are a good location to keep source-code, copies of scripts and compiled binaries. Small amounts of important data can also be copied here for safe keeping though the file systems are not fast enough to manipulate large datasets effectively. Warning Files with filenames that contain non-ascii characters and/or non-printable characters cannot be backed up using our automated process and so will be omitted from all backups.","title":"Home file systems"},{"location":"user-guide/data/#work-file-systems","text":"There are three independent work file-systems: /fs2 1.5PB /fs3 1.5PB /fs4 1.8PB Every project has an allocation on one of the three. You do not need to know which one your project uses as your projects space can always be accessed via the path /work/project-code . These are high-performance, Lustre parallel file systems. They are designed to support data in large files. The performance for data stored in large numbers of small files is probably not going to be as good. These are the only file systems that are available on the compute nodes so all data read or written by jobs running on the compute nodes has to be hosted here. Warning There are no backups of any data on the work file systems. You should not rely on these file systems for long term storage. Ideally, these file systems should only contain data that is: actively in use; recently generated and in the process of being saved elsewhere; or being made ready for up-coming work. In practice it may be convenient to keep copies of datasets on the work file systems that you know will be needed at a later date. However, make sure that important data is always backed up elsewhere and that your work would not be significantly impacted if the data on the work file systems was lost. Large data sets can be copied to the RDF storage or transferred off the ARCHER2 service entirely. If you have data on the work file systems that you are not going to need in the future please delete it.","title":"Work file systems"},{"location":"user-guide/data/#solid-state-storage","text":"","title":"Solid state storage"},{"location":"user-guide/data/#rdf-storage","text":"","title":"RDF storage"},{"location":"user-guide/data/#archiving-and-data-transfer","text":"Data transfer speed may be limited by many different factors so the best data transfer mechanism to use depends on the type of data being transferred and where the data is going. Disk speed - The ARCHER2 /work file-systems and the RDF file-systems are highly parallel consisting of a very large number of high performance disk drives. This allows them to support a very high data bandwidth. Unless the remote system has a similar parallel file-system you may find your transfer speed limited by disk performance. Meta-data performance - Meta-data operations such as opening and closing files or listing the owner or size of a file are much less parallel than read/write operations. If your data consists of a very large number of small files you may find your transfer speed is limited by meta-data operations. Meta-data operations performed by other users of the system will interact strongly with those you perform so reducing the number of such operations you use, may reduce variability in your IO timings. Network speed - Data transfer performance can be limited by network speed. More importantly it is limited by the slowest section of the network between source and destination. Firewall speed - Most modern networks are protected by some form of firewall that filters out malicious traffic. This filtering has some overhead and can result in a reduction in data transfer performance. The needs of a general purpose network that hosts email/web-servers and desktop machines are quite different from a research network that needs to support high volume data transfers. If you are trying to transfer data to or from a host on a general purpose network you may find the firewall for that network will limit the transfer rate you can achieve. The method you use to transfer data to/from ARCHER2 will depend on how much you want to transfer and where to. The methods we cover in this guide are: scp/sftp/rsync - These are the simplest methods of transferring data and can be used up to moderate amounts of data. If you are transferring data to your workstation/laptop then this is the method you will use. Globus Online (GO) - If you are transferring large amounts of data to another central computing facility then GO provides high performance parallel data transfer functionality. Both ends of the transfer must be setup as GO endpoints (ARCHER2 is configured as a GO endpoint. Before discussing specific data transfer methods, we cover archiving which is an essential process for transferring data efficiently.","title":"Archiving and data transfer"},{"location":"user-guide/data/#archiving","text":"If you have related data that consists of a large number of small files it is strongly recommended to pack the files into a larger \"archive\" file for ease of transfer and manipulation. A single large file makes more efficient use of the file system and is easier to move and copy and transfer because significantly fewer meta-data operations are required. Archive files can be created using tools like tar and zip .","title":"Archiving"},{"location":"user-guide/data/#tar","text":"The tar command packs files into a \"tape archive\" format. The command has general form: tar [options] [file(s)] Common options include: -c create a new archive -v verbosely list files processed -W verify the archive after writing -l confirm all file hard links are included in the archive -f use an archive file (for historical reasons, tar writes its output to stdout by default rather than a file). Putting these together: tar -cvWlf mydata.tar mydata will create and verify an archive. To extract files from a tar file, the option -x is used. For example: tar -xf mydata.tar will recover the contents of mydata.tar to the current working directory. To verify an existing tar file against a set of data, the -d (diff) option can be used. By default, no output will be given if a verification succeeds and an example of a failed verification follows: $> tar -df mydata.tar mydata/* mydata/damaged_file: Mod time differs mydata/damaged_file: Size differs Note that tar files do not store checksums with their data, requiring the original data to be present during verification. Further information on using tar can be found in the tar manual (accessed via man tar or at man tar ).","title":"tar"},{"location":"user-guide/data/#zip","text":"The zip file format is widely used for archiving files and is supported by most major operating systems. The utility to create zip files can be run from the command line as: zip [options] mydata.zip [file(s)] Common options are: -r used to zip up a directory -# where \"#\" represents a digit ranging from 0 to 9 to specify compression level, 0 being the least and 9 the most. Default compression is -6 but we recommend using -0 to speed up the archiving process. Together: zip -0r mydata.zip mydata will create an archive. Note Unlike tar, zip files do not preserve hard links. File data will be copied on archive creation, e.g. an uncompressed zip archive of a 100MB file and a hard link to that file will be approximately 200MB in size. This makes zip an unsuitable format if you wish to precisely reproduce the file system layout. The corresponding unzip command is used to extract data from the archive. The simplest use case is: unzip mydata.zip which recovers the contents of the archive to the current working directory. Files in a zip archive are stored with a CRC checksum to help detect data loss. unzip provides options for verifying this checksum against the stored files. The relevant flag is -t and is used as follows: $> unzip -t mydata.zip Archive: mydata.zip testing: mydata/ OK testing: mydata/file OK No errors detected in compressed data of mydata.zip. Further information on using zip can be found in the zip manual (accessed via man zip or at man zip ).","title":"zip"},{"location":"user-guide/data/#data-transfer-via-ssh","text":"The easiest way of transferring data to/from ARCHER2 is to use one of the standard programs based on the SSH protocol such as scp , sftp or rsync . These all use the same underlying mechanism (SSH) as you normally use to log-in to ARCHER2. So, once the the command has been executed via the command line, you will be prompted for your password for the specified account on the remote machine (ARCHER2 in this case). To avoid having to type in your password multiple times you can set up a SSH key pair and use an SSH agent as documented in the User Guide at connecting .","title":"Data transfer via SSH"},{"location":"user-guide/data/#ssh-data-transfer-performance-considerations","text":"The SSH protocol encrypts all traffic it sends. This means that file transfer using SSH consumes a relatively large amount of CPU time at both ends of the transfer (for encryption and decryption). The ARCHER2 login nodes have fairly fast processors that can sustain about 100 MB/s transfer. The encryption algorithm used is negotiated between the SSH client and the SSH server. There are command line flags that allow you to specify a preference for which encryption algorithm should be used. You may be able to improve transfer speeds by requesting a different algorithm than the default. The aes128-ctr or aes256-ctr algorithms are well supported and fast as they are implemented in hardware. Note: these are not usually the default choice when using scp so you will need to manually specify them. A single SSH based transfer will usually not be able to saturate the available network bandwidth or the available disk bandwidth so you may see an overall improvement by running several data transfer operations in parallel. To reduce metadata interactions it is a good idea to overlap transfers of files from different directories. In addition, you should consider the following when transferring data: Only transfer those files that are required. Consider which data you really need to keep. Combine lots of small files into a single tar archive, to reduce the overheads associated in initiating many separate data transfers (over SSH, each file counts as an individual transfer). Compress data before transferring it, e.g. using gzip .","title":"SSH data transfer performance considerations"},{"location":"user-guide/data/#scp","text":"The scp command creates a copy of a file, or if given the -r flag, a directory either from a local machine onto a remote machine or from a remote machine onto a local machine. For example, to transfer files to ARCHER2 from a local machine: scp [options] source user@login.archer2.ac.uk:[destination] (Remember to replace user with your ARCHER2 username in the example above.) In the above example, the [destination] is optional, as when left out scp will copy the source into your home directory. Also, the source should be the absolute path of the file/directory being copied or the command should be executed in the directory containing the source file/directory. If you want to request a different encryption algorithm add the -c [algorithm-name] flag to the scp options. For example, to use the (usually faster) arcfour encryption algorithm you would use: scp [options] -c aes128-ctr source user@login.archer2.ac.uk:[destination] (Remember to replace user with your ARCHER2 username in the example above.)","title":"scp"},{"location":"user-guide/data/#rsync","text":"The rsync command can also transfer data between hosts using a ssh connection. It creates a copy of a file or, if given the -r flag, a directory at the given destination, similar to scp above. Given the -a option rsync can also make exact copies (including permissions), this is referred to as mirroring . In this case the rsync command is executed with ssh to create the copy on a remote machine. To transfer files to ARCHER2 using rsync with ssh the command has the form: rsync [options] -e ssh source user@login.archer2.ac.uk:[destination] (Remember to replace user with your ARCHER2 username in the example above.) In the above example, the [destination] is optional, as when left out rsync will copy the source into your home directory. Also the source should be the absolute path of the file/directory being copied or the command should be executed in the directory containing the source file/directory. Additional flags can be specified for the underlying ssh command by using a quoted string as the argument of the -e flag. e.g. rsync [options] -e \"ssh -c arcfour\" source user@login.archer2.ac.uk:[destination] (Remember to replace user with your ARCHER2 username in the example above.) Further information on using rsync can be found in the rsync manual (accessed via man rsync or at man rsync ).","title":"rsync"},{"location":"user-guide/data/#globus-online-go","text":"Globus online is a web-based file transfer portal provided by the Globus project: www.globus.org You will need to register with the web portal and create an account before you can use GO. Internally, GO uses the GridFTP file transfer mechanism but the web portal provides a simple user interface and handles all the management of file transfers. GO will retry failed transfers and send notifications when transfers complete so there is no need to stay logged into the web portal while transfers are ongoing. To transfer data between sites, both ends of the transfer need to support a GO endpoint . GO also provide a client you can install on your laptop or workstation that can act as a local endpoint (though you often do not have a network connection with sufficient bandwidth from your local system to support high performance data transfers). You have to activate an endpoint before use, either by enabling the connector software on your local machine or by providing login details in your browser for a server endpoint. Once activated, endpoints will remain active for a couple of days allowing transfers to complete. The GO endpoint on ARCHER2 is called \"ARCHER2\". When activating this endpoint use the same username and password you use to login to ARCHER2.","title":"Globus online (GO)"},{"location":"user-guide/debug/","text":"Debugging Warning The ARCHER2 Service is not yet available. This documentation is in development. The following debugging tools are available on ARCHER2: gdb4hpc is a command-line debugging tool provided by Cray. It works similarly to gdb , but allows the user to debug multiple parallel processes without multiple windows. gdb4hpc can be used to investigate deadlocked code, segfaults, and other errors for C/C++ and Fortran code. Users can single-step code and focus on specific processes groups to help identify unexpected code behavior. (text from ALCF ). valgrind4hpc is a parallel memory debugging tool that aids in detection of memory leaks and errors in parallel applications. It aggregates like errors across processes and threads to simply debugging of parallel applications. STAT generate merged stack traces for parallel applications. Also has visualisation tools. * ATP scalable core file and backtrace analysis when parallel programs crash. Note that this is not currently working on ARCHER2. .. * CCDB Cray Comparative Debugger. Compare two versions of code side-by-side to analyse differences. gdb4hpc The GNU Debugger for HPC (gdb4hpc) is a GDB-based debugger used to debug applications compiled with CCE, PGI, GNU, and Intel Fortran, C and C++ compilers. It allows programmers to either launch an application within it or to attach to an already-running application. Attaching to an already-running and hanging application is a quick way of understanding why the application is hanging, whereas launching an application through gdb4hpc will allow you to see your application running step-by-step, output the values of variables, and check whether the application runs as expected. Note For your executable to be compatible with gdb4hpc, it will need to be coded with MPI. You will also need to compile your code with the debugging flag -g (e.g. cc -g my_program.c -o my_exe ). Launching through gdb4hpc Launch gdb4hpc : gdb4hpc You will get some information about this version of the program and, eventually, you will get a command prompt: gdb4hpc 4.5 - Cray Line Mode Parallel Debugger With Cray Comparative Debugging Technology. Copyright 2007-2019 Cray Inc. All Rights Reserved. Copyright 1996-2016 University of Queensland. All Rights Reserved. Type \"help\" for a list of commands. Type \"help <cmd>\" for detailed help about a command. dbg all> We will use launch to begin a multi-process application within gdb4hpc. Consider that we are wanting to test an application called my_exe , and that we want this to be launched across all 256 processes in two nodes. We would launch this in gdb4hpc by running: dbg all> launch --launcher-args=\"--tasks-per-node=128 --cpus-per-task=1 --exclusive\" $my_prog{256} ./my_ex The default launcher is srun and the --launcher-args=\"...\" allows you to set launcher flags for srun . The variable $my_prog is a dummy name for the program being launched and you could use whatever name you want for it -- this will be the name of the srun job that will be run. The number in the brackets {256} is the number of processes over which the program will be executed, it's 256 here, but you could use any number. You should try to run this on as few processors as possible -- the more you use, the longer it will take for gdb4hpc to load the program. Once the program is launched, gdb4hpc will load up the program and begin to run it. You will get output to screen something that looks like: Starting application, please wait... Creating MRNet communication network... Waiting for debug servers to attach to MRNet communications network... Timeout in 400 seconds. Please wait for the attach to complete. Number of dbgsrvs connected: [0]; Timeout Counter: [1] Number of dbgsrvs connected: [0]; Timeout Counter: [2] Number of dbgsrvs connected: [0]; Timeout Counter: [3] Number of dbgsrvs connected: [1]; Timeout Counter: [0] Number of dbgsrvs connected: [1]; Timeout Counter: [1] Number of dbgsrvs connected: [2]; Timeout Counter: [0] Finalizing setup... Launch complete. my_prog{0..255}: Initial breakpoint, main at /PATH/TO/my_program.c:34 The line number at which the initial breakpoint is made (in the above example, line 34) corresponds to the line number at which MPI is initialised. You will not be able to see any parts of the code outside of the MPI region of a code with gdb4hpc. Once the code is loaded, you can use various commands to move through your code. The following lists and describes some of the most useful ones: help -- Lists all gdb4hpc commands. You can run help COMMAND_NAME to learn more about a specific command ( e.g. help launch will tell you about the launch command list -- Will show the current line of code and the 9 lines following. Repeated use of list will move you down the code in ten-line chunks. next -- Will jump to the next step in the program for each process and output which line of code each process is one. It will not enter subroutines. Note that there is no reverse-step in gdb4hpc. step -- Like next , but this will step into subroutines. up -- Go up one level in the program ( e.g. from a subroutine back to main). print var -- Prints the value of variable var at this point in the code. watch var -- Like print, but will print whenever a variable changes value. quit -- Exits gdb4hpc. Remember to exit the interactive session once you are done debugging. Attaching with gdb4hpc Attaching to a hanging job using gdb4hpc is a great way of seeing which state each processor is in. However, this does not produce the most visually appealing results. For a more easy-to-read program, please take a look at STAT In your interactive session, launch your executable as a background task (by adding an & at the end of the command). For example, if you are running an executable called my_exe using 256 processes, you would run: srun -n 256 --nodes=2 --tasks-per-node=128 --cpus-per-task=1 --time=01:00:00 --account=[budget code] ./my_exe & Make sure to replace the --account input to your budget code ( e.g. if you are using budget t01, that part should look like --account=t01 ). You will need to get the full job ID of the job you have just launched. To do this, run: squeue -u $USER and find the job ID associated with this interactive session -- this will be the one with the jobname bash . In this example: JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 1050 workq my_mpi_j jsindt R 0:16 1 nid000001 1051 workq bash jsindt R 0:12 1 nid000002 the appropriate job id is 1051. Next, you will need to run sstat on this job id: sstat 1051 This will output a large amount of information about this specific job. We are looking for the first number of this output, which should look like JOB_ID.## -- the number after the job ID is the number of slurm tasks performed in this interactive session. For our example (where srun is the first slurm task performed), the number is 1051.0. Launch gdb4hpc : gdb4hpc You will get some information about this version of the program and, eventually, you will get a command prompt: gdb4hpc 4.5 - Cray Line Mode Parallel Debugger With Cray Comparative Debugging Technology. Copyright 2007-2019 Cray Inc. All Rights Reserved. Copyright 1996-2016 University of Queensland. All Rights Reserved. Type \"help\" for a list of commands. Type \"help <cmd>\" for detailed help about a command. dbg all> We will be using the attach command to attach to our program that hangs. This is done by writing: :: dbg all> attach $my_prog JOB_ID.## where JOB_ID.## is the full job ID found using sstat (in our example, this would be 1051.0). The name $my_prog is a dummy-name -- it could be whatever name you like. As it is attaching, gdb4hpc will output text to screen that looks like: Attaching to application, please wait... Creating MRNet communication network... Waiting for debug servers to attach to MRNet communications network... Timeout in 400 seconds. Please wait for the attach to complete. Number of dbgsrvs connected: [0]; Timeout Counter: [1] ... Finalizing setup... Attach complete. Current rank location: After this, you will get an output that, among other things, tells you which line of your code each process is on, and what each process is doing. This can be helpful to see where the hang-up is. If you accidentally attached to the wrong job, you can detach by running: dbg all> release $my_prog and re-attach with the correct job ID. You will need to change your dummy name from $my_prog to something else. When you are finished using gbd4hpc , simply run: dbg all> quit Do not forget to exit your interactive session. valgrind4hpc Valgrind4hpc is a Valgrind-based debugging tool to aid in the detection of memory leaks and errors in parallel applications. Valgrind4hpc aggregates any duplicate messages across ranks to help provide an understandable picture of program behavior. Valgrind4hpc manages starting and redirecting output from many copies of Valgrind, as well as recombining and filtering Valgrind messages. If your program can be debugged with Valgrind, it can be debugged with valgrind4hpc. The valgrind4hpc module enables the use of standard valgrind as well as the valgrind4hpc version more suitable to parallel programs. Warning There is a known issue with `valgrind4hpc`: the compiler wrappers (ftn, cc, CC) do not work while this module is loaded. To compile, you will need to unload the module ( module unload valgrind4hpc ), compile, and reload the module ( module load valrgind4hpc ). Using valgrind First, load valgrind4hpc : module load valgrind4hpc Next, run your executable through valgrind: valgrind --tool=memcheck --leak-check=yes my_executable The log outputs to screen. The ERROR SUMMARY will tell you whether, and how many, memory errors there are in your script. Furthermore, if you compile your code using the -g debugging flag ( e.g. gcc -g my_progam.c -o my_executable.c ), the log will point out the code lines where the error occurs. Valgrind also includes a tool called Massif that can be used to give insight into the memory usage of your program. It takes regular snapshots and outputs this data into a single file, which can be visualised to show the total amount of memory used as a function of time. This shows when peaks and bottlenecks occur and allows you to identify which data structures in your code are responsible for the largest memory usage of your program. Documentation explaining how to use Massif is available at the official Massif manual . In short, you should run your executable as follows: valgrind --tool=massif my_executable he memory profiling data will be output into a file called massif.out.pid , where pid is the runtime process ID of your program. A custom filename can be chosen using the --massif-out-file option , as follows: valgrind --tool=massif --massif-out-file=optional_filename.out my_executable The output file contains raw profiling statistics. To view a summary including a graphical plot of memory usage over time, use the ms_print command as follows: ms_print massif.out.12345 or, to save to a file: ms_print massif.out.12345 > massif.analysis.12345 This will show total memory usage over time as well as a breakdown of the top data structures contributing to memory usage at each snapshot where there has been a significant allocation or deallocation of memory. Using valgrind4hpc First, load valgrind4hpc : module load valgrind4hpc Valgrind4hpc will launch an srun job to run the executable while it profiles. To test an executable called my_executable that requires two arguments arg1 and arg2 on two nodes and 256 processes, run: valgrind4hpc --tool=memcheck --num-ranks=256 --launcher-args=\"--exclusive --ntasks-per-node=128 --cpus-per-task=1\" my_executable -- arg1 arg2 In particular, note the -- separating the executable from the arguments (this is not necessary of your executable takes no arguments). The --lancher-args=\"arguments\" allow you to set launcher flags for srun . Valgrind4hpc only supports certain tools found in valgrind. These are: memcheck, helgrind, exp-sgcheck, or drd. The --valgrind-args=\"arguments\" allows users to use valgrind options not supported in valgrind4hpc ( e.g. --leak-check ) -- note, however, that some of these options might interfere with valgrind4hpc. More information on valgrind4hpc can be found in the manual ( man valgrind4hpc ). STAT The Stack Trace Analysis Tool (STAT) is a cross-platform debugging tool from the University of Wisconsin-Madison. ATP is based on the same technology as STAT, both are designed to gather and merge stack traces from a running application's parallel processes. The STAT tool can be useful when application seems to be deadlocked or stuck, i.e. they don't crash but they don't progress as expected, and it has been designed to scale to a very large number of processes. Full information on STAT, including use cases, is available at the STAT website . STAT will attach to a running program and query that program to find out where all the processes in that program currently are. It will then process that data and produce a graph displaying the unique process locations (i.e. where all the processes in the running program currently are). To make this easily understandable it collates together all processes that are in the same place providing only unique program locations for display. Using STAT on ARCHER2 On the login node, load the cray-stat module: module load cray-stat Then, launch your job using srun as a background task (by adding an & at the end of the command). For example, if you are running an executable called my_exe using 256 processes, you would run: srun -n=256 --nodes=2 --tasks-per-node=128 --cpus-per-task=1 --time=01:00:00 --account=[budget code] ./my_exe & Note that this example has set the job time limit to 1 hour -- if you need longer, change the --time command. You will need the Program ID (PID) of the job you have just launched -- the PID is printed to screen upon launch, or you can get it by running: ps -u $USER This will present you with a set of text that looks like this: PID TTY TIME CMD 154296 ? 00:00:00 systemd 154297 ? 00:00:00 (sd-pam) 154302 ? 00:00:00 sshd 154303 pts/8 00:00:00 bash 157150 pts/8 00:00:00 salloc 157152 pts/8 00:00:00 bash 157183 pts/8 00:00:00 srun 157185 pts/8 00:00:00 srun 157191 pts/8 00:00:00 ps Once your application has reached the point where it hangs, issue the following command (replacing PID with the ID of the first srun task -- in the above example, I would replace PID with 157183): stat-cl -i PID You will get an output that looks like this: STAT started at 2020-07-22-13:31:35 Attaching to job launcher (null):157565 and launching tool daemons... Tool daemons launched and connected! Attaching to application... Attached! Application already paused... ignoring request to pause Sampling traces... Traces sampled! Resuming the application... Resumed! Pausing the application... Paused! ... Detaching from application... Detached! Results written to $PATH_TO_RUN_DIRECTORY/stat_results/my_exe.0000 Once STAT is finished, you can kill the srun job using scancel (replacing JID with the job ID of the job you just launched): scancel JID You can view the results that STAT has produced using the following command (note that \"my_exe\" will need to be replaced with the name of the executable you ran): stat-view stat_results/my_exe.0000/00_my_exe.0000.3D.dot This produces a graph displaying all the different places within the program that the parallel processes were when you queried them. Note To see the graph, you will need to have exported your X display when logging in. ATP To enable ATP you should load the atp module and set the \"ATP_ENABLED\" environment variable to 1 on the login node: module load atp export ATP_ENABLED=1 Then, launch your job using srun as a background task (by adding an & at the end of the command). For example, if you are running an executable called my_exe using 256 processes, you would run: srun -n=256 --nodes=2 --tasks-per-node=128 --cpus-per-task=1 --time=01:00:00 --account=[budget code] ./my_exe & Note that this example has set the job time limit to 1 hour -- if you need longer, change the --time command. Once the job has finished running, load the stat module to view the results: module load cray-stat and view the merged stack trace using: stat-view atpMergedBT.dot Note To see the graph, you will need to have exported your X display when logging in.","title":"Debug"},{"location":"user-guide/debug/#debugging","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. The following debugging tools are available on ARCHER2: gdb4hpc is a command-line debugging tool provided by Cray. It works similarly to gdb , but allows the user to debug multiple parallel processes without multiple windows. gdb4hpc can be used to investigate deadlocked code, segfaults, and other errors for C/C++ and Fortran code. Users can single-step code and focus on specific processes groups to help identify unexpected code behavior. (text from ALCF ). valgrind4hpc is a parallel memory debugging tool that aids in detection of memory leaks and errors in parallel applications. It aggregates like errors across processes and threads to simply debugging of parallel applications. STAT generate merged stack traces for parallel applications. Also has visualisation tools. * ATP scalable core file and backtrace analysis when parallel programs crash. Note that this is not currently working on ARCHER2. .. * CCDB Cray Comparative Debugger. Compare two versions of code side-by-side to analyse differences.","title":"Debugging"},{"location":"user-guide/debug/#gdb4hpc","text":"The GNU Debugger for HPC (gdb4hpc) is a GDB-based debugger used to debug applications compiled with CCE, PGI, GNU, and Intel Fortran, C and C++ compilers. It allows programmers to either launch an application within it or to attach to an already-running application. Attaching to an already-running and hanging application is a quick way of understanding why the application is hanging, whereas launching an application through gdb4hpc will allow you to see your application running step-by-step, output the values of variables, and check whether the application runs as expected. Note For your executable to be compatible with gdb4hpc, it will need to be coded with MPI. You will also need to compile your code with the debugging flag -g (e.g. cc -g my_program.c -o my_exe ).","title":"gdb4hpc"},{"location":"user-guide/debug/#launching-through-gdb4hpc","text":"Launch gdb4hpc : gdb4hpc You will get some information about this version of the program and, eventually, you will get a command prompt: gdb4hpc 4.5 - Cray Line Mode Parallel Debugger With Cray Comparative Debugging Technology. Copyright 2007-2019 Cray Inc. All Rights Reserved. Copyright 1996-2016 University of Queensland. All Rights Reserved. Type \"help\" for a list of commands. Type \"help <cmd>\" for detailed help about a command. dbg all> We will use launch to begin a multi-process application within gdb4hpc. Consider that we are wanting to test an application called my_exe , and that we want this to be launched across all 256 processes in two nodes. We would launch this in gdb4hpc by running: dbg all> launch --launcher-args=\"--tasks-per-node=128 --cpus-per-task=1 --exclusive\" $my_prog{256} ./my_ex The default launcher is srun and the --launcher-args=\"...\" allows you to set launcher flags for srun . The variable $my_prog is a dummy name for the program being launched and you could use whatever name you want for it -- this will be the name of the srun job that will be run. The number in the brackets {256} is the number of processes over which the program will be executed, it's 256 here, but you could use any number. You should try to run this on as few processors as possible -- the more you use, the longer it will take for gdb4hpc to load the program. Once the program is launched, gdb4hpc will load up the program and begin to run it. You will get output to screen something that looks like: Starting application, please wait... Creating MRNet communication network... Waiting for debug servers to attach to MRNet communications network... Timeout in 400 seconds. Please wait for the attach to complete. Number of dbgsrvs connected: [0]; Timeout Counter: [1] Number of dbgsrvs connected: [0]; Timeout Counter: [2] Number of dbgsrvs connected: [0]; Timeout Counter: [3] Number of dbgsrvs connected: [1]; Timeout Counter: [0] Number of dbgsrvs connected: [1]; Timeout Counter: [1] Number of dbgsrvs connected: [2]; Timeout Counter: [0] Finalizing setup... Launch complete. my_prog{0..255}: Initial breakpoint, main at /PATH/TO/my_program.c:34 The line number at which the initial breakpoint is made (in the above example, line 34) corresponds to the line number at which MPI is initialised. You will not be able to see any parts of the code outside of the MPI region of a code with gdb4hpc. Once the code is loaded, you can use various commands to move through your code. The following lists and describes some of the most useful ones: help -- Lists all gdb4hpc commands. You can run help COMMAND_NAME to learn more about a specific command ( e.g. help launch will tell you about the launch command list -- Will show the current line of code and the 9 lines following. Repeated use of list will move you down the code in ten-line chunks. next -- Will jump to the next step in the program for each process and output which line of code each process is one. It will not enter subroutines. Note that there is no reverse-step in gdb4hpc. step -- Like next , but this will step into subroutines. up -- Go up one level in the program ( e.g. from a subroutine back to main). print var -- Prints the value of variable var at this point in the code. watch var -- Like print, but will print whenever a variable changes value. quit -- Exits gdb4hpc. Remember to exit the interactive session once you are done debugging.","title":"Launching through gdb4hpc"},{"location":"user-guide/debug/#attaching-with-gdb4hpc","text":"Attaching to a hanging job using gdb4hpc is a great way of seeing which state each processor is in. However, this does not produce the most visually appealing results. For a more easy-to-read program, please take a look at STAT In your interactive session, launch your executable as a background task (by adding an & at the end of the command). For example, if you are running an executable called my_exe using 256 processes, you would run: srun -n 256 --nodes=2 --tasks-per-node=128 --cpus-per-task=1 --time=01:00:00 --account=[budget code] ./my_exe & Make sure to replace the --account input to your budget code ( e.g. if you are using budget t01, that part should look like --account=t01 ). You will need to get the full job ID of the job you have just launched. To do this, run: squeue -u $USER and find the job ID associated with this interactive session -- this will be the one with the jobname bash . In this example: JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 1050 workq my_mpi_j jsindt R 0:16 1 nid000001 1051 workq bash jsindt R 0:12 1 nid000002 the appropriate job id is 1051. Next, you will need to run sstat on this job id: sstat 1051 This will output a large amount of information about this specific job. We are looking for the first number of this output, which should look like JOB_ID.## -- the number after the job ID is the number of slurm tasks performed in this interactive session. For our example (where srun is the first slurm task performed), the number is 1051.0. Launch gdb4hpc : gdb4hpc You will get some information about this version of the program and, eventually, you will get a command prompt: gdb4hpc 4.5 - Cray Line Mode Parallel Debugger With Cray Comparative Debugging Technology. Copyright 2007-2019 Cray Inc. All Rights Reserved. Copyright 1996-2016 University of Queensland. All Rights Reserved. Type \"help\" for a list of commands. Type \"help <cmd>\" for detailed help about a command. dbg all> We will be using the attach command to attach to our program that hangs. This is done by writing: :: dbg all> attach $my_prog JOB_ID.## where JOB_ID.## is the full job ID found using sstat (in our example, this would be 1051.0). The name $my_prog is a dummy-name -- it could be whatever name you like. As it is attaching, gdb4hpc will output text to screen that looks like: Attaching to application, please wait... Creating MRNet communication network... Waiting for debug servers to attach to MRNet communications network... Timeout in 400 seconds. Please wait for the attach to complete. Number of dbgsrvs connected: [0]; Timeout Counter: [1] ... Finalizing setup... Attach complete. Current rank location: After this, you will get an output that, among other things, tells you which line of your code each process is on, and what each process is doing. This can be helpful to see where the hang-up is. If you accidentally attached to the wrong job, you can detach by running: dbg all> release $my_prog and re-attach with the correct job ID. You will need to change your dummy name from $my_prog to something else. When you are finished using gbd4hpc , simply run: dbg all> quit Do not forget to exit your interactive session.","title":"Attaching with gdb4hpc"},{"location":"user-guide/debug/#valgrind4hpc","text":"Valgrind4hpc is a Valgrind-based debugging tool to aid in the detection of memory leaks and errors in parallel applications. Valgrind4hpc aggregates any duplicate messages across ranks to help provide an understandable picture of program behavior. Valgrind4hpc manages starting and redirecting output from many copies of Valgrind, as well as recombining and filtering Valgrind messages. If your program can be debugged with Valgrind, it can be debugged with valgrind4hpc. The valgrind4hpc module enables the use of standard valgrind as well as the valgrind4hpc version more suitable to parallel programs. Warning There is a known issue with `valgrind4hpc`: the compiler wrappers (ftn, cc, CC) do not work while this module is loaded. To compile, you will need to unload the module ( module unload valgrind4hpc ), compile, and reload the module ( module load valrgind4hpc ).","title":"valgrind4hpc"},{"location":"user-guide/debug/#using-valgrind","text":"First, load valgrind4hpc : module load valgrind4hpc Next, run your executable through valgrind: valgrind --tool=memcheck --leak-check=yes my_executable The log outputs to screen. The ERROR SUMMARY will tell you whether, and how many, memory errors there are in your script. Furthermore, if you compile your code using the -g debugging flag ( e.g. gcc -g my_progam.c -o my_executable.c ), the log will point out the code lines where the error occurs. Valgrind also includes a tool called Massif that can be used to give insight into the memory usage of your program. It takes regular snapshots and outputs this data into a single file, which can be visualised to show the total amount of memory used as a function of time. This shows when peaks and bottlenecks occur and allows you to identify which data structures in your code are responsible for the largest memory usage of your program. Documentation explaining how to use Massif is available at the official Massif manual . In short, you should run your executable as follows: valgrind --tool=massif my_executable he memory profiling data will be output into a file called massif.out.pid , where pid is the runtime process ID of your program. A custom filename can be chosen using the --massif-out-file option , as follows: valgrind --tool=massif --massif-out-file=optional_filename.out my_executable The output file contains raw profiling statistics. To view a summary including a graphical plot of memory usage over time, use the ms_print command as follows: ms_print massif.out.12345 or, to save to a file: ms_print massif.out.12345 > massif.analysis.12345 This will show total memory usage over time as well as a breakdown of the top data structures contributing to memory usage at each snapshot where there has been a significant allocation or deallocation of memory.","title":"Using valgrind"},{"location":"user-guide/debug/#using-valgrind4hpc","text":"First, load valgrind4hpc : module load valgrind4hpc Valgrind4hpc will launch an srun job to run the executable while it profiles. To test an executable called my_executable that requires two arguments arg1 and arg2 on two nodes and 256 processes, run: valgrind4hpc --tool=memcheck --num-ranks=256 --launcher-args=\"--exclusive --ntasks-per-node=128 --cpus-per-task=1\" my_executable -- arg1 arg2 In particular, note the -- separating the executable from the arguments (this is not necessary of your executable takes no arguments). The --lancher-args=\"arguments\" allow you to set launcher flags for srun . Valgrind4hpc only supports certain tools found in valgrind. These are: memcheck, helgrind, exp-sgcheck, or drd. The --valgrind-args=\"arguments\" allows users to use valgrind options not supported in valgrind4hpc ( e.g. --leak-check ) -- note, however, that some of these options might interfere with valgrind4hpc. More information on valgrind4hpc can be found in the manual ( man valgrind4hpc ).","title":"Using valgrind4hpc"},{"location":"user-guide/debug/#stat","text":"The Stack Trace Analysis Tool (STAT) is a cross-platform debugging tool from the University of Wisconsin-Madison. ATP is based on the same technology as STAT, both are designed to gather and merge stack traces from a running application's parallel processes. The STAT tool can be useful when application seems to be deadlocked or stuck, i.e. they don't crash but they don't progress as expected, and it has been designed to scale to a very large number of processes. Full information on STAT, including use cases, is available at the STAT website . STAT will attach to a running program and query that program to find out where all the processes in that program currently are. It will then process that data and produce a graph displaying the unique process locations (i.e. where all the processes in the running program currently are). To make this easily understandable it collates together all processes that are in the same place providing only unique program locations for display.","title":"STAT"},{"location":"user-guide/debug/#using-stat-on-archer2","text":"On the login node, load the cray-stat module: module load cray-stat Then, launch your job using srun as a background task (by adding an & at the end of the command). For example, if you are running an executable called my_exe using 256 processes, you would run: srun -n=256 --nodes=2 --tasks-per-node=128 --cpus-per-task=1 --time=01:00:00 --account=[budget code] ./my_exe & Note that this example has set the job time limit to 1 hour -- if you need longer, change the --time command. You will need the Program ID (PID) of the job you have just launched -- the PID is printed to screen upon launch, or you can get it by running: ps -u $USER This will present you with a set of text that looks like this: PID TTY TIME CMD 154296 ? 00:00:00 systemd 154297 ? 00:00:00 (sd-pam) 154302 ? 00:00:00 sshd 154303 pts/8 00:00:00 bash 157150 pts/8 00:00:00 salloc 157152 pts/8 00:00:00 bash 157183 pts/8 00:00:00 srun 157185 pts/8 00:00:00 srun 157191 pts/8 00:00:00 ps Once your application has reached the point where it hangs, issue the following command (replacing PID with the ID of the first srun task -- in the above example, I would replace PID with 157183): stat-cl -i PID You will get an output that looks like this: STAT started at 2020-07-22-13:31:35 Attaching to job launcher (null):157565 and launching tool daemons... Tool daemons launched and connected! Attaching to application... Attached! Application already paused... ignoring request to pause Sampling traces... Traces sampled! Resuming the application... Resumed! Pausing the application... Paused! ... Detaching from application... Detached! Results written to $PATH_TO_RUN_DIRECTORY/stat_results/my_exe.0000 Once STAT is finished, you can kill the srun job using scancel (replacing JID with the job ID of the job you just launched): scancel JID You can view the results that STAT has produced using the following command (note that \"my_exe\" will need to be replaced with the name of the executable you ran): stat-view stat_results/my_exe.0000/00_my_exe.0000.3D.dot This produces a graph displaying all the different places within the program that the parallel processes were when you queried them. Note To see the graph, you will need to have exported your X display when logging in.","title":"Using STAT on ARCHER2"},{"location":"user-guide/debug/#atp","text":"To enable ATP you should load the atp module and set the \"ATP_ENABLED\" environment variable to 1 on the login node: module load atp export ATP_ENABLED=1 Then, launch your job using srun as a background task (by adding an & at the end of the command). For example, if you are running an executable called my_exe using 256 processes, you would run: srun -n=256 --nodes=2 --tasks-per-node=128 --cpus-per-task=1 --time=01:00:00 --account=[budget code] ./my_exe & Note that this example has set the job time limit to 1 hour -- if you need longer, change the --time command. Once the job has finished running, load the stat module to view the results: module load cray-stat and view the merged stack trace using: stat-view atpMergedBT.dot Note To see the graph, you will need to have exported your X display when logging in.","title":"ATP"},{"location":"user-guide/dev-environment/","text":"Application development environment Warning The ARCHER2 Service is not yet available. This documentation is in development. What's available ARCHER2 runs on the Cray Linux Environment (a version of SUSU Linux), and provides a Cray Developer Environment (CDE) which includes: Software modules via a standard module framework Three different compiler environments (AMD, Cray, and GNU) MPI, OpenMP, and SHMEM Scientific and numerical libraries Parallel Python and R Parallel debugging and profiling SLURM scheduler and job management Singularity containers Access to particular software, and particular versions, is managed via the module framework. For a broad overview, a full list of what's available can be seen by typing $ module avail A full discussion of the module system is available in sw-environment . Warning The following statement needs to be confirmed By default, all users on ARCHER2 start with no modules loaded. Developing applications then means selecting and loading an appropriate set of modules before starting work. This section is aimed at code developers and will concentrate on the compilation environment and building executables, and specifically parallel executables. Other topics such as python and containers are covered in more detail in separate sections of the documentation. Managing development ARCHER2 supports common revision control software such as git , svn , and mercurial . Standard GNU autoconf tools are available, along with make (which is GNU Make). Versions of cmake are avilable. Compilation via the queue system Build jobs which take considerable time, or use considerable resources (via e.g., make -j ), should be considered candidates for the queue system. As the hardware and software environment on both the login nodes and the back end nodes is uniform on ARCHER2, there are no special considerations for building applications via the queue system. Compilation Environment There are three different compiler environments avialable: AMD, Cray, and GNU. These are accessed by loading the appropriate programming environment module, i.e., exactly one of: $ module load PrgEnv-aocc $ module load PrgEnv-cray $ module load PrgEnv-gnu This will give access to a consistent set of compiler and message passing interface (MPI) intrastructure. Compilation of C, C++, and Fortran soruce code should then take place using the appropriate compiler wrapper: cc , CC , and ftn , respectively. The wrapper will automatically call the relevant underlying compiler and add the appropriate include directories and library locations to the invocation. This typically eliminates the need to specify this additional information explicitly in the configuration stage. Users should not, in general, invoke specific compilers. In particular, gcc , which may default to /usr/bin/gcc , should not be used. The compiler wrappers cc , CC , and ftn should be used via the appropriate module. However, one exception is if specific man pages are required. The command man cc etc will provide the man page on the compiler wrapper. Specific compiler man pages are invoked via the underlying compiler name, which are given in the relevant sections below. General remarks on compilation All Cray-provided modules will automatically be compatible with the appropriate compiler environment. E.g., to use NetCDF module load PrgEnv-cray module load cray-netcdf and use the appropriate compiler wrapper to ensure the correct header files and modules can be located at compile time, and the correct libraries at link time. Note Further general remarks on compilation will appear here. Note As ARCHER2 uses dynamic linking by default you will generally also need to load any modules you used to compile your code in your job submission script when you run your code. Which compiler environment? If you are unsure which compiler you should choose, we suggest the starting point should be the GNU compiler collection; this is probably the most commonly used by code developers. For users requiring specific compiler features, such as co-array Fortran, the recommended starting point would be Cray. AMD Optimizing Compiler Collection (AOCC) Cray Compiler Environment (CCE) GNU Compiler Collection (GCC) The GNU compiler collection is loaded via $ module load PrgEnv-gnu Full details of behaviour of the compilers can be seen on individual man pages via man gcc , man g++ or man gfortran . Here we provide a summary of a number of useful options. Feature Option Comments Enable OpenMP -fopenmp Must be used at both compile and link time Message passing interface (MPI) MPICH Cray provide as standard an MPICH implementation of the message passing interface which is specifically optimised for the ARCHER2 network. This implementation should be used wherever possibile. Some common resource limits e.g., number of communicators, number of message tags, will be documented here. Useful environment variables assoicated with MPICH will be documented here. ABI compatability. This may be useful in cases where a source distribution is not available. Using a different MPI Note Details will appear here (if this is possible) Linking and Libraries Using static linking By default, executables on ARCHER2 are built using shared/dynamic libraries (that is, libraries which are loaded at run-time as and when needed by the application) when using the wrapper scripts. An application compiled this way to use shared/dynamic libraries will use the default version of the library installed on the system (just like any other Linux executable), even if the system modules were set differently at compile time. This means that the application may potentially be using slightly different object code each time the application runs as the defaults may change. This is usually the desired behaviour for many applications as any fixes or improvements to the default linked libraries are used without having to recompile the application, however some users may feel this is not the desired behaviour for their applications. Alternatively, applications can be compiled to use static libraries (i.e. all of the object code of referenced libraries are contained in the executable file). This has the advantage that once an executable is created, whenever it is run in the future, it will always use the same object code (within the limit of changing runtime environemnt). However, executables compiled with static libraries have the potential disadvantage that when multiple instances are running simultaneously multiple copies of the libraries used are held in memory. This can lead to large amounts of memory being used to hold the executable and not application data. To create an application that uses static libraries you must pass an extra flag during compilation, -Bstatic . Use the UNIX command ldd exe_file to check whether you are using an executable that depends on shared libraries. This utility will also report the shared libraries this executable will use if it has been dynamically linked. Commonly used libraries Cray scientific libraries, available for all compiler choices via module load cray-libsci provides access to the Fortran BLAS and LAPACK interface for basic linear algebra, the corresponding C interfaces CBLAS and LAPACKE , and BLACS and ScaLAPACK for parallel linear algebra. FFTW provides Fast Fourrier Transforms, and is available via module load fftw3 Note that FFTW Version 2 is no longer supported. Developers are strongly advised to move to FFTW Version 3. Hierarchical Data Format HDF5 is available via $ module load hdf Network Common Data Form NetCDF is available via $ module load netcdf A full description of the relationship between various HDF5 and NetCDF options will appear here. Building standard packages The ARCHER2 team provide Build configurations for a number of standard libraries and software packages. Users wanting particular versions of public packages, particularly development versions which are not available centrally, are encourage to try the Build configuration and consult the Service Desk if there are problems. Note Full details will appear as they become avaialble","title":"Dev environment"},{"location":"user-guide/dev-environment/#application-development-environment","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development.","title":"Application development environment"},{"location":"user-guide/dev-environment/#whats-available","text":"ARCHER2 runs on the Cray Linux Environment (a version of SUSU Linux), and provides a Cray Developer Environment (CDE) which includes: Software modules via a standard module framework Three different compiler environments (AMD, Cray, and GNU) MPI, OpenMP, and SHMEM Scientific and numerical libraries Parallel Python and R Parallel debugging and profiling SLURM scheduler and job management Singularity containers Access to particular software, and particular versions, is managed via the module framework. For a broad overview, a full list of what's available can be seen by typing $ module avail A full discussion of the module system is available in sw-environment . Warning The following statement needs to be confirmed By default, all users on ARCHER2 start with no modules loaded. Developing applications then means selecting and loading an appropriate set of modules before starting work. This section is aimed at code developers and will concentrate on the compilation environment and building executables, and specifically parallel executables. Other topics such as python and containers are covered in more detail in separate sections of the documentation.","title":"What's available"},{"location":"user-guide/dev-environment/#managing-development","text":"ARCHER2 supports common revision control software such as git , svn , and mercurial . Standard GNU autoconf tools are available, along with make (which is GNU Make). Versions of cmake are avilable.","title":"Managing development"},{"location":"user-guide/dev-environment/#compilation-via-the-queue-system","text":"Build jobs which take considerable time, or use considerable resources (via e.g., make -j ), should be considered candidates for the queue system. As the hardware and software environment on both the login nodes and the back end nodes is uniform on ARCHER2, there are no special considerations for building applications via the queue system.","title":"Compilation via the queue system"},{"location":"user-guide/dev-environment/#compilation-environment","text":"There are three different compiler environments avialable: AMD, Cray, and GNU. These are accessed by loading the appropriate programming environment module, i.e., exactly one of: $ module load PrgEnv-aocc $ module load PrgEnv-cray $ module load PrgEnv-gnu This will give access to a consistent set of compiler and message passing interface (MPI) intrastructure. Compilation of C, C++, and Fortran soruce code should then take place using the appropriate compiler wrapper: cc , CC , and ftn , respectively. The wrapper will automatically call the relevant underlying compiler and add the appropriate include directories and library locations to the invocation. This typically eliminates the need to specify this additional information explicitly in the configuration stage. Users should not, in general, invoke specific compilers. In particular, gcc , which may default to /usr/bin/gcc , should not be used. The compiler wrappers cc , CC , and ftn should be used via the appropriate module. However, one exception is if specific man pages are required. The command man cc etc will provide the man page on the compiler wrapper. Specific compiler man pages are invoked via the underlying compiler name, which are given in the relevant sections below.","title":"Compilation Environment"},{"location":"user-guide/dev-environment/#general-remarks-on-compilation","text":"All Cray-provided modules will automatically be compatible with the appropriate compiler environment. E.g., to use NetCDF module load PrgEnv-cray module load cray-netcdf and use the appropriate compiler wrapper to ensure the correct header files and modules can be located at compile time, and the correct libraries at link time. Note Further general remarks on compilation will appear here. Note As ARCHER2 uses dynamic linking by default you will generally also need to load any modules you used to compile your code in your job submission script when you run your code.","title":"General remarks on compilation"},{"location":"user-guide/dev-environment/#which-compiler-environment","text":"If you are unsure which compiler you should choose, we suggest the starting point should be the GNU compiler collection; this is probably the most commonly used by code developers. For users requiring specific compiler features, such as co-array Fortran, the recommended starting point would be Cray.","title":"Which compiler environment?"},{"location":"user-guide/dev-environment/#amd-optimizing-compiler-collection-aocc","text":"","title":"AMD Optimizing Compiler Collection (AOCC)"},{"location":"user-guide/dev-environment/#cray-compiler-environment-cce","text":"","title":"Cray Compiler Environment (CCE)"},{"location":"user-guide/dev-environment/#gnu-compiler-collection-gcc","text":"The GNU compiler collection is loaded via $ module load PrgEnv-gnu Full details of behaviour of the compilers can be seen on individual man pages via man gcc , man g++ or man gfortran . Here we provide a summary of a number of useful options. Feature Option Comments Enable OpenMP -fopenmp Must be used at both compile and link time","title":"GNU Compiler Collection (GCC)"},{"location":"user-guide/dev-environment/#message-passing-interface-mpi","text":"","title":"Message passing interface (MPI)"},{"location":"user-guide/dev-environment/#mpich","text":"Cray provide as standard an MPICH implementation of the message passing interface which is specifically optimised for the ARCHER2 network. This implementation should be used wherever possibile. Some common resource limits e.g., number of communicators, number of message tags, will be documented here. Useful environment variables assoicated with MPICH will be documented here. ABI compatability. This may be useful in cases where a source distribution is not available.","title":"MPICH"},{"location":"user-guide/dev-environment/#using-a-different-mpi","text":"Note Details will appear here (if this is possible)","title":"Using a different MPI"},{"location":"user-guide/dev-environment/#linking-and-libraries","text":"","title":"Linking and Libraries"},{"location":"user-guide/dev-environment/#using-static-linking","text":"By default, executables on ARCHER2 are built using shared/dynamic libraries (that is, libraries which are loaded at run-time as and when needed by the application) when using the wrapper scripts. An application compiled this way to use shared/dynamic libraries will use the default version of the library installed on the system (just like any other Linux executable), even if the system modules were set differently at compile time. This means that the application may potentially be using slightly different object code each time the application runs as the defaults may change. This is usually the desired behaviour for many applications as any fixes or improvements to the default linked libraries are used without having to recompile the application, however some users may feel this is not the desired behaviour for their applications. Alternatively, applications can be compiled to use static libraries (i.e. all of the object code of referenced libraries are contained in the executable file). This has the advantage that once an executable is created, whenever it is run in the future, it will always use the same object code (within the limit of changing runtime environemnt). However, executables compiled with static libraries have the potential disadvantage that when multiple instances are running simultaneously multiple copies of the libraries used are held in memory. This can lead to large amounts of memory being used to hold the executable and not application data. To create an application that uses static libraries you must pass an extra flag during compilation, -Bstatic . Use the UNIX command ldd exe_file to check whether you are using an executable that depends on shared libraries. This utility will also report the shared libraries this executable will use if it has been dynamically linked.","title":"Using static linking"},{"location":"user-guide/dev-environment/#commonly-used-libraries","text":"Cray scientific libraries, available for all compiler choices via module load cray-libsci provides access to the Fortran BLAS and LAPACK interface for basic linear algebra, the corresponding C interfaces CBLAS and LAPACKE , and BLACS and ScaLAPACK for parallel linear algebra. FFTW provides Fast Fourrier Transforms, and is available via module load fftw3 Note that FFTW Version 2 is no longer supported. Developers are strongly advised to move to FFTW Version 3. Hierarchical Data Format HDF5 is available via $ module load hdf Network Common Data Form NetCDF is available via $ module load netcdf A full description of the relationship between various HDF5 and NetCDF options will appear here.","title":"Commonly used libraries"},{"location":"user-guide/dev-environment/#building-standard-packages","text":"The ARCHER2 team provide Build configurations for a number of standard libraries and software packages. Users wanting particular versions of public packages, particularly development versions which are not available centrally, are encourage to try the Build configuration and consult the Service Desk if there are problems. Note Full details will appear as they become avaialble","title":"Building standard packages"},{"location":"user-guide/io/","text":"I/O and file systems Warning The ARCHER2 Service is not yet available. This documentation is in development. Using the ARCHER2 file systems Different file systems are configured for different purposes and performance. ARCHER2 has three file systems available to users: Node type Available file systems Login /home | /work Compute /work | SSS PP Warning Any data used in a parallel jobs should be located on /work (Lustre) or the solid state storage. Home Warning This file system is backed up for disaster recovery purposes only. Data recovery for accidental deletion is not supported. Home directories provide a convenient means for a user to have access to files such as source files, input files or configuration files. This file system is only mounted on the login nodes. The home directory for each user is located at: /home/[project code]/[group code]/[username] where [project code] is the code for your project (e.g., x01); [group code] is the code for your project group, if your project has groups, (e.g. x01-a) or the same as the project code, if not; [username] is your login name. Each project is allocated a portion of the total storage available, and the project PI will be able to sub-divide this quota among the groups and users within the project. As is standard practice on UNIX and Linux systems, the environment variable $HOME is automatically set to point to your home directory. It should be noted that the home file system is not designed, and does not have the capacity, to act as a long term archive for large sets of results. Work Warning There is no separate backup of data on any of the work file systems, which means that in the event of a major hardware failure, or if a user accidently deletes essential data, it will not be possible to recover the lost files. High-performance Lustre file system mounted on the compute nodes. All parallel calculations must be run from directories on the /work file system and all files required by the calculation (apart from the executable) must reside on /work . Each project will be assigned space on a particular Lustre partition with the assignments chosen to balance the load across the available infrastructure. The work directory for each user is located at: /work/[project code]/[group code]/[username] where [project code] is the code for your project (e.g., x01); [group code] is the code for your project group, if your project has groups, (e.g. x01-a) or the same as the project code, if not; [username] is your login name. Links from the /home file system to directories or files on /work are strongly discouraged. If links are used, executables and data files on /work to be used by applications on the compute nodes (i.e. those executed via the aprun command) should be referenced directly on /work . Solid State Storage (SSS) Warning This section is in development and it will be completed as soon as possible. The 1.1 PiB ARCHER2 solid state file system significantly increase the I/O performance for all file sizes and access patterns. Disk quotas Sharing data with other ARCHER2 users How you share data with other ARCHER2 users depends on whether they belong to the same project as you or not. Each project has two levels of shared directories that can be used for sharing data. Sharing data with users in your project Each project has a directory called: /work/[project code]/[project code]/shared that has read/write permissions for all project members. You can place any data you wish to share with other project members in this directory. For example, if your project code is x01 the shared project directory would be located at: /work/x01/x01/shared Sharing data with all users Each project also has a higher level directory called: /work/[project code]/shared that is writable by all project members and readable by any user on the system. You can place any data you wish to share with other ARCHER2 users who are not members of your project in this directory. For example, if your project code is x01 the sharing directory would be located at: /work/x01/shared Common I/O patterns There is a number of I/O patterns that are frequently used in applications: Single file, single writer (Serial I/O) A common approach is to funnel all the I/O through a single master process. Although this has the advantage of producing a single file, the fact that only a single client is doing all the I/O means that it gains little benefit from the parallel file system. File-per-process (FPP) One of the first parallel strategies people use for I/O is for each parallel process to write to its own file. This is a simple scheme to implement and understand but has the disadvantage that, at the end of the calculation, the data is spread across many different files and may therefore be difficult to use for further analysis without a data reconstruction stage. Single file, multiple writers without collective operations There are a number of ways to achieve this. For example, many processes can open the same file but access different parts by skipping some initial offset; parallel I/O libraries such as MPI-IO, HDF5 and NetCDF also enable this. Shared-file I/O has the advantage that all the data is organised correctly in a single file making analysis or restart more straightforward. The problem is that, with many clients all accessing the same file, there can be a lot of contention for file system resources. Single Shared File with collective writes (SSF) The problem with having many clients performing I/O at the same time is that, to prevent them clashing with each other, the I/O library may have to take a conservative approach. For example, a file may be locked while each client is accessing it which means that I/O is effectively serialised and performance may be poor. However, if I/O is done collectively where the library knows that all clients are doing I/O at the same time, then reads and writes can be explicitly coordinated to avoid clashes. It is only through collective I/O that the full bandwidth of the file system can be realised while accessing a single file. Achieving efficient I/O This section provides information on getting the best performance out of the parallel /work file systems on ARCHER2 when writing data, particularly using parallel I/O patterns. Lustre The ARCHER2 /work file systems use Lustre as a parallel file system technology. The Lustre file system provides POSIX semantics (changes on one node are immediately visible on other nodes) and can support very high data rates for appropriate I/O patterns. Striping One of the main factors leading to the high performance of Lustre file systems is the ability to stripe data across multiple Object Storage Targets (OSTs) in a round-robin fashion. Files are striped when the data is split up in chunks that will then be stored on different OSTs across the Lustre system. Striping might improve the I/O performance because it increases the available bandwith since multiple processes can read and write the same files simultaneously. However striping can also increase the overhead. Choosing the right striping configuration is key to obtain high performance results. Users have control of a number of striping settings on Lustre file systems. Although these parameters can be set on a per-file basis they are usually set on directory where your output files will be written so that all output files inherit the settings. Default configuration The /work file systems on ARCHER2 have the same default stripe settings: A default stripe count of 1 A default stripe size of 1 MiB (1048576 bytes) These settings have been chosen to provide a good compromise for the wide variety of I/O patterns that are seen on the system but are unlikely to be optimal for any one particular scenario. The Lustre command to query the stripe settings for a directory (or file) is lfs getstripe . For example, to query the stripe settings of an already created directory res_dir : [user@archer2]$ lfs getstripe res_dir/ res_dir stripe_count: 1 stripe_size: 1048576 stripe_offset: -1 Setting Custom Striping Configurations Users can set stripe settings for a directory (or file) using the lfs setstripe command. The options for lfs setstripe are: [--stripe-count|-c] to set the stripe count; 0 means use the system default (usually 1) and -1 means stripe over all available OSTs. [--stripe-size|-s] to set the stripe size; 0 means use the system default (usually 1 MB) otherwise use k, m or g for KB, MB or GB respectively [--stripe-index|-i] to set the OST index (starting at 0) on which to start striping for this file. An index of -1 allows the MDS to choose the starting index and it is strongly recommended, as this allows space and load balancing to be done by the MDS as needed. For example, to set a stripe size of 4 MiB for the existing directory res_dir , along with maximum striping count you would use: [user@archer2]$ lfs setstripe -s 4m -c -1 res_dir/ Recommended ARCHER2 I/O settings I/O Profiling ARCHER2 has a number of tools available for users to profile and analyse the I/O activity of software applications. CrayPat Darshan","title":"Io"},{"location":"user-guide/io/#io-and-file-systems","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development.","title":"I/O and file systems"},{"location":"user-guide/io/#using-the-archer2-file-systems","text":"Different file systems are configured for different purposes and performance. ARCHER2 has three file systems available to users: Node type Available file systems Login /home | /work Compute /work | SSS PP Warning Any data used in a parallel jobs should be located on /work (Lustre) or the solid state storage.","title":"Using the ARCHER2 file systems"},{"location":"user-guide/io/#home","text":"Warning This file system is backed up for disaster recovery purposes only. Data recovery for accidental deletion is not supported. Home directories provide a convenient means for a user to have access to files such as source files, input files or configuration files. This file system is only mounted on the login nodes. The home directory for each user is located at: /home/[project code]/[group code]/[username] where [project code] is the code for your project (e.g., x01); [group code] is the code for your project group, if your project has groups, (e.g. x01-a) or the same as the project code, if not; [username] is your login name. Each project is allocated a portion of the total storage available, and the project PI will be able to sub-divide this quota among the groups and users within the project. As is standard practice on UNIX and Linux systems, the environment variable $HOME is automatically set to point to your home directory. It should be noted that the home file system is not designed, and does not have the capacity, to act as a long term archive for large sets of results.","title":"Home"},{"location":"user-guide/io/#work","text":"Warning There is no separate backup of data on any of the work file systems, which means that in the event of a major hardware failure, or if a user accidently deletes essential data, it will not be possible to recover the lost files. High-performance Lustre file system mounted on the compute nodes. All parallel calculations must be run from directories on the /work file system and all files required by the calculation (apart from the executable) must reside on /work . Each project will be assigned space on a particular Lustre partition with the assignments chosen to balance the load across the available infrastructure. The work directory for each user is located at: /work/[project code]/[group code]/[username] where [project code] is the code for your project (e.g., x01); [group code] is the code for your project group, if your project has groups, (e.g. x01-a) or the same as the project code, if not; [username] is your login name. Links from the /home file system to directories or files on /work are strongly discouraged. If links are used, executables and data files on /work to be used by applications on the compute nodes (i.e. those executed via the aprun command) should be referenced directly on /work .","title":"Work"},{"location":"user-guide/io/#solid-state-storage-sss","text":"Warning This section is in development and it will be completed as soon as possible. The 1.1 PiB ARCHER2 solid state file system significantly increase the I/O performance for all file sizes and access patterns.","title":"Solid State Storage (SSS)"},{"location":"user-guide/io/#disk-quotas","text":"","title":"Disk quotas"},{"location":"user-guide/io/#sharing-data-with-other-archer2-users","text":"How you share data with other ARCHER2 users depends on whether they belong to the same project as you or not. Each project has two levels of shared directories that can be used for sharing data.","title":"Sharing data with other ARCHER2 users"},{"location":"user-guide/io/#sharing-data-with-users-in-your-project","text":"Each project has a directory called: /work/[project code]/[project code]/shared that has read/write permissions for all project members. You can place any data you wish to share with other project members in this directory. For example, if your project code is x01 the shared project directory would be located at: /work/x01/x01/shared","title":"Sharing data with users in your project"},{"location":"user-guide/io/#sharing-data-with-all-users","text":"Each project also has a higher level directory called: /work/[project code]/shared that is writable by all project members and readable by any user on the system. You can place any data you wish to share with other ARCHER2 users who are not members of your project in this directory. For example, if your project code is x01 the sharing directory would be located at: /work/x01/shared","title":"Sharing data with all users"},{"location":"user-guide/io/#common-io-patterns","text":"There is a number of I/O patterns that are frequently used in applications:","title":"Common I/O patterns"},{"location":"user-guide/io/#single-file-single-writer-serial-io","text":"A common approach is to funnel all the I/O through a single master process. Although this has the advantage of producing a single file, the fact that only a single client is doing all the I/O means that it gains little benefit from the parallel file system.","title":"Single file, single writer (Serial I/O)"},{"location":"user-guide/io/#file-per-process-fpp","text":"One of the first parallel strategies people use for I/O is for each parallel process to write to its own file. This is a simple scheme to implement and understand but has the disadvantage that, at the end of the calculation, the data is spread across many different files and may therefore be difficult to use for further analysis without a data reconstruction stage.","title":"File-per-process (FPP)"},{"location":"user-guide/io/#single-file-multiple-writers-without-collective-operations","text":"There are a number of ways to achieve this. For example, many processes can open the same file but access different parts by skipping some initial offset; parallel I/O libraries such as MPI-IO, HDF5 and NetCDF also enable this. Shared-file I/O has the advantage that all the data is organised correctly in a single file making analysis or restart more straightforward. The problem is that, with many clients all accessing the same file, there can be a lot of contention for file system resources.","title":"Single file, multiple writers without collective operations"},{"location":"user-guide/io/#single-shared-file-with-collective-writes-ssf","text":"The problem with having many clients performing I/O at the same time is that, to prevent them clashing with each other, the I/O library may have to take a conservative approach. For example, a file may be locked while each client is accessing it which means that I/O is effectively serialised and performance may be poor. However, if I/O is done collectively where the library knows that all clients are doing I/O at the same time, then reads and writes can be explicitly coordinated to avoid clashes. It is only through collective I/O that the full bandwidth of the file system can be realised while accessing a single file.","title":"Single Shared File with collective writes (SSF)"},{"location":"user-guide/io/#achieving-efficient-io","text":"This section provides information on getting the best performance out of the parallel /work file systems on ARCHER2 when writing data, particularly using parallel I/O patterns.","title":"Achieving efficient I/O"},{"location":"user-guide/io/#lustre","text":"The ARCHER2 /work file systems use Lustre as a parallel file system technology. The Lustre file system provides POSIX semantics (changes on one node are immediately visible on other nodes) and can support very high data rates for appropriate I/O patterns.","title":"Lustre"},{"location":"user-guide/io/#striping","text":"One of the main factors leading to the high performance of Lustre file systems is the ability to stripe data across multiple Object Storage Targets (OSTs) in a round-robin fashion. Files are striped when the data is split up in chunks that will then be stored on different OSTs across the Lustre system. Striping might improve the I/O performance because it increases the available bandwith since multiple processes can read and write the same files simultaneously. However striping can also increase the overhead. Choosing the right striping configuration is key to obtain high performance results. Users have control of a number of striping settings on Lustre file systems. Although these parameters can be set on a per-file basis they are usually set on directory where your output files will be written so that all output files inherit the settings.","title":"Striping"},{"location":"user-guide/io/#default-configuration","text":"The /work file systems on ARCHER2 have the same default stripe settings: A default stripe count of 1 A default stripe size of 1 MiB (1048576 bytes) These settings have been chosen to provide a good compromise for the wide variety of I/O patterns that are seen on the system but are unlikely to be optimal for any one particular scenario. The Lustre command to query the stripe settings for a directory (or file) is lfs getstripe . For example, to query the stripe settings of an already created directory res_dir : [user@archer2]$ lfs getstripe res_dir/ res_dir stripe_count: 1 stripe_size: 1048576 stripe_offset: -1","title":"Default configuration"},{"location":"user-guide/io/#setting-custom-striping-configurations","text":"Users can set stripe settings for a directory (or file) using the lfs setstripe command. The options for lfs setstripe are: [--stripe-count|-c] to set the stripe count; 0 means use the system default (usually 1) and -1 means stripe over all available OSTs. [--stripe-size|-s] to set the stripe size; 0 means use the system default (usually 1 MB) otherwise use k, m or g for KB, MB or GB respectively [--stripe-index|-i] to set the OST index (starting at 0) on which to start striping for this file. An index of -1 allows the MDS to choose the starting index and it is strongly recommended, as this allows space and load balancing to be done by the MDS as needed. For example, to set a stripe size of 4 MiB for the existing directory res_dir , along with maximum striping count you would use: [user@archer2]$ lfs setstripe -s 4m -c -1 res_dir/","title":"Setting Custom Striping Configurations"},{"location":"user-guide/io/#recommended-archer2-io-settings","text":"","title":"Recommended ARCHER2 I/O settings"},{"location":"user-guide/io/#io-profiling","text":"ARCHER2 has a number of tools available for users to profile and analyse the I/O activity of software applications.","title":"I/O Profiling"},{"location":"user-guide/io/#craypat","text":"","title":"CrayPat"},{"location":"user-guide/io/#darshan","text":"","title":"Darshan"},{"location":"user-guide/profile/","text":"Profiling c Warning The ARCHER2 Service is not yet available. This documentation is in development. CrayPat-lite CrayPat-lite is a simplified and easy-to-use version of the Cray Performance Measurement and Analysis Tool (CrayPat) set. CrayPat-lite provides basic performance analysis information automatically, with a minimum of user interaction, and yet offers information useful to users wishing to explore a program's behavior further using the full CrayPat tool set. To use CrayPat-lite you only need to make sure that the base CrayPat perftools-base module has been loaded, an instrumentation module can then be loaded for further experimentation. How to use CrayPat-lite Ensure the perftools-base module is loaded module list Load perfotools-lite module module load perftools-lite Compile your application normally. An information message from CrayPat-lite will appear indicating that the executable has been instrumented. [user@archer2]$ cc -h std=c99 -o myapplication.x myapplication.c INFO: creating the CrayPat-instrumented executable 'myapplication.x' (lite-samples) ...OK Run the generated executable normally submitting a job. Warning The following SLURM script is provisional and should be verified #!/bin/bash #SBATCH --job-name=craypat_test #SBATCH --nodes=4 #SBATCH --tasks-per-node=128 #SBATCH --cpus-per-task=1 #SBATCH --time=00:20:00 #SBATCH --account=[budget code] srun mpi_test.x Analyse the data After the job finishes executing, CrayPat-lite output should be printed to stdout i.e. at the end of the job's output file generated. A new directory will also be created in the directory the run occurred in with .rpt and .ap2 files. The .rpt files are text files that contain the same information printed in the job's output file, the .ap2 files can be used to obtained more detailed information and can be visualized with the Cray Apprentice2 tool. Further help CrayPat-lite User Guide CrayPat The Cray Performance Analysis Tool (CrayPAT) is a powerful framework for analysing a parallel application\u2019s performance on Cray supercomputers. It can provide very detailed information on the timing and performance of individual application procedures. CrayPat can perform two types of performance analysis: sampling experiments and tracing experiments. A sampling experiment probes the code at a predefined interval and produces a report based on these statistics. A tracing experiment explicitly monitors the code performance within named routines. Typically, the overhead associated with a tracing experiment is higher than that associated with a sampling experiment but provides much more detailed information. The key to getting useful data out of a sampling experiment is to run your profiling for a representative length of time. Sampling analysis Ensure the perftools-base module is loaded module list Load perftools module module load perftools Compile your code in the standard way always using the Cray compiler wrappers (ftn, cc and CC). Object files need to be made available to CrayPat to correctly build an instrumented executable for profiling or tracing, this means that compile and link stage should be separated by using the -c compile flag. [user@archer2]$ cc -h std=c99 -c jacobi.c [user@archer2]$ cc jacobi.o -o jacobi Instrument your application To instrument then the binary, run the pat_build command. This will generate a new binary with +pat appended to the end (e.g. jacobi+pat ) [user@archer2]$ pat_build jacobi Run the new executable with +pat appended as you would with the regular executable. This will generate performance data files with the suffix .xf (e.g. jacobi+pat+12265-1573s/xf-files ). Generate report data This .xt file contains the raw sampling data from the run and needs to be post processed to produce useful results. This is done using the pat_report tool which converts all the raw data into a summarised and readable form. : [user@archer2]$ pat_report jacobi+pat+12265-1573s Table 1: Profile by Function (limited entries shown) Samp% | Samp | Imb. | Imb. | Group | | Samp | Samp% | Function | | | | PE=HIDE 100.0% | 849.5 | -- | -- | Total 56.7% | 481.4 | -- | -- | MPI || 48.7% | 414.1 | 50.9 | 11.0% | MPI_Allreduce || 4.4% | 37.5 | 118.5 | 76.6% | MPI_Waitall || 3.0% | 25.2 | 44.8 | 64.5% | MPI_Isend | 29.9% | 253.9 | 55.1 | 18.0% | USER || 29.9% | 253.9 | 55.1 | 18.0% | main | 13.4% | 114.1 | -- | -- | ETC || 13.4% | 113.9 | 26.1 | 18.8% | __cray_memcpy_SNB |================================================== This report will generate two more files, one with the extension .ap2 which holds the same data as the .xf but in the post processed form. The other file has a .apa extension and is a text file with a suggested configuration for generating a traced experiment. The .ap2 file generated is used to view performance data graphically with the Cray Apprentice2 tool, and the latter is used for more detailed tracing experiments. The pat_report command is able to produce many different profile reports from the profile data. You can select a predefined report with the -O flag to pat_report . A selection of the most generally useful predefined report types are ca+src - Show the callers (bottom-up view) leading to the routines that have a high use in the report and include source code line numbers for the calls and time-consuming statements. load_balance - Show load-balance statistics for the high-use routines in the program. Parallel processes with minimum, maximum and median times for routines will be displayed. Only available with tracing experiments. mpi_callers - Show MPI message statistics. Only available with tracing experiments. [user@archer2]$ pat_report -O ca+src,load_balance jacobi+pat+12265-1573s Table 1: Profile by Function and Callers, with Line Numbers (limited entries shown) Samp% | Samp | Imb. | Imb. | Group | | Samp | Samp% | Function | | | | PE=HIDE 100.0% | 849.5 | -- | -- | Total --------------------------------------| 56.7% | 481.4 | MPI || 48.7% | 414.1 | MPI_Allreduce 3| | | main:jacobi.c:line.80 || 4.4% | 37.5 | MPI_Waitall 3| | | main:jacobi.c:line.73 || 3.0% | 25.2 | MPI_Isend ||| 1.6% | 13.2 | main:jacobi.c:line.65 3|| 1.4% | 12.0 | main:jacobi.c:line.69 | 29.9% | 253.9 | USER || 29.9% | 253.9 | main ||| 18.7% | 159.0 | main:jacobi.c:line.76 3|| 9.1% | 76.9 | main:jacobi.c:line.84 || 13.4% | 114.1 | ETC || 13.4% | 113.9 | __cray_memcpy_SNB 3| | | __cray_memcpy_SNB |====================================== Tracing analysis Automatic Program Analysis (APA) We can produce a focused tracing experiment based on the results from the sampling experiment using pat_build with the .apa file produced during the sampling. [user@archer2]$ pat_build -O jacobi+pat+12265-1573s/build-options.apa This will produce a third binary with extension +apa . This binary should once again be run on the compute nodes and the name of the executable changed to jacobi+apa . As with the sampling analysis, a report can be produced using pat_report . [user@archer2]$ pat_report jacobi+apa+13955-1573t Table 1: Profile by Function Group and Function (limited entries shown) Time% | Time | Imb. | Imb. | Calls | Group | | Time | Time% | | Function | | | | | PE=HIDE 100.0% | 12.987762 | -- | -- | 1,387,544.9 | Total 44.9% | 5.831320 | -- | -- | 2.0 | USER || 44.9% | 5.831229 | 0.398671 | 6.4% | 1.0 | main | 29.2% | 3.789904 | -- | -- | 199,111.0 | MPI_SYNC || 29.2% | 3.789115 | 1.792050 | 47.3% | 199,109.0 | MPI_Allreduce(sync) | 25.9% | 3.366537 | -- | -- | 1,188,431.9 | MPI || 18.0% | 2.334765 | 0.164646 | 6.6% | 199,109.0 | MPI_Allreduce || 3.7% | 0.486714 | 0.882654 | 65.0% | 199,108.0 | MPI_Waitall || 3.3% | 0.428731 | 0.557342 | 57.0% | 395,104.9 | MPI_Isend |========================================================================= Manual Program Analysis CrayPat allows you to manually choose your profiling preference. This is particularly useful if the APA mode does not meet your tracing analysis requirements. The entire program can be traced as a whole using -w : [user@archer2]$ pat_build -w jacobi Using -g a program can be instrumented to trace all function entry point references belonging to the trace function group tracegroup (mpi, libsci, lapack, scalapack, heap, etc) [user@archer2]$ pat_build -w -g mpi jacobi Dynamically-linked binaries CrayPat allows you to profile un-instrumented, dynamically linked binaries with the pat_run utility. pat_run delivers profiling information for codes that cannot easily be rebuilt. To use pat_run : Load the perfotools-base module if it is not already loaded module load perftools-base Run your application normally including the pat_run command rigth after your srun options srun [srun-options] pat_run [pat_run-options] program [program-options] Use pat_report to examine any data collected during the execution of your application. [user@archer2]$ pat_report jacobi+pat+12265-1573s Some useful pat_run options are: -w Collect data by tracing. -g Trace functions belonging to group names. See the -g option in pat_build(1) for a list of valid tracegroup values. -r Generate a text report upon successful execution. Further help CrayPat User Guide Cray Apprentice2 Cray Apprentice2 is an optional GUI tool that is used to visualize and manipulate the performance analysis data captured during program execution. Cray Apprentice2 can be run either on the Cray system or, optionally, on a standalone Linux desktop machine. Cray Apprentice2 can display a wide variety of reports and graphs, depending on the type of program being analyzed, the way in which the program was instrumented for data capture, and the data that was collected during program execution. You will need to use CrayPat first, to instrument your program and capture performance analysis data, and then use Cray Apprentice2 to visualize and explore the resulting data files. The number and appearance of the reports that can be generated using Cray Apprentice2 is determined by the kind and quantity of data captured during program execution, which in turn is determined by the way in which the program was instrumented and the environment variables in effect at the time of program execution. For example, changing the PAT_RT_SUMMARY environment variable to 0 before executing the instrumented program nearly doubles the number of reports available when analyzing the resulting data in Cray Apprentice2. export PAT_RT_SUMMARY=0 To use Cray Apprentice2 ( app2 ), load perftools-base module if it is not already loaded module load perftools-base then open the Cray Apprentice2 data ( .ap2 ) generated during the instrumentation phase [user@archer2]$ app2 jacobi+pat+12265-1573s/datafile.ap2 Hardware Performance Counters","title":"Profile"},{"location":"user-guide/profile/#profiling","text":"c Warning The ARCHER2 Service is not yet available. This documentation is in development.","title":"Profiling"},{"location":"user-guide/profile/#craypat-lite","text":"CrayPat-lite is a simplified and easy-to-use version of the Cray Performance Measurement and Analysis Tool (CrayPat) set. CrayPat-lite provides basic performance analysis information automatically, with a minimum of user interaction, and yet offers information useful to users wishing to explore a program's behavior further using the full CrayPat tool set. To use CrayPat-lite you only need to make sure that the base CrayPat perftools-base module has been loaded, an instrumentation module can then be loaded for further experimentation.","title":"CrayPat-lite"},{"location":"user-guide/profile/#how-to-use-craypat-lite","text":"Ensure the perftools-base module is loaded module list Load perfotools-lite module module load perftools-lite Compile your application normally. An information message from CrayPat-lite will appear indicating that the executable has been instrumented. [user@archer2]$ cc -h std=c99 -o myapplication.x myapplication.c INFO: creating the CrayPat-instrumented executable 'myapplication.x' (lite-samples) ...OK Run the generated executable normally submitting a job. Warning The following SLURM script is provisional and should be verified #!/bin/bash #SBATCH --job-name=craypat_test #SBATCH --nodes=4 #SBATCH --tasks-per-node=128 #SBATCH --cpus-per-task=1 #SBATCH --time=00:20:00 #SBATCH --account=[budget code] srun mpi_test.x Analyse the data After the job finishes executing, CrayPat-lite output should be printed to stdout i.e. at the end of the job's output file generated. A new directory will also be created in the directory the run occurred in with .rpt and .ap2 files. The .rpt files are text files that contain the same information printed in the job's output file, the .ap2 files can be used to obtained more detailed information and can be visualized with the Cray Apprentice2 tool.","title":"How to use CrayPat-lite"},{"location":"user-guide/profile/#further-help","text":"CrayPat-lite User Guide","title":"Further help"},{"location":"user-guide/profile/#craypat","text":"The Cray Performance Analysis Tool (CrayPAT) is a powerful framework for analysing a parallel application\u2019s performance on Cray supercomputers. It can provide very detailed information on the timing and performance of individual application procedures. CrayPat can perform two types of performance analysis: sampling experiments and tracing experiments. A sampling experiment probes the code at a predefined interval and produces a report based on these statistics. A tracing experiment explicitly monitors the code performance within named routines. Typically, the overhead associated with a tracing experiment is higher than that associated with a sampling experiment but provides much more detailed information. The key to getting useful data out of a sampling experiment is to run your profiling for a representative length of time.","title":"CrayPat"},{"location":"user-guide/profile/#sampling-analysis","text":"Ensure the perftools-base module is loaded module list Load perftools module module load perftools Compile your code in the standard way always using the Cray compiler wrappers (ftn, cc and CC). Object files need to be made available to CrayPat to correctly build an instrumented executable for profiling or tracing, this means that compile and link stage should be separated by using the -c compile flag. [user@archer2]$ cc -h std=c99 -c jacobi.c [user@archer2]$ cc jacobi.o -o jacobi Instrument your application To instrument then the binary, run the pat_build command. This will generate a new binary with +pat appended to the end (e.g. jacobi+pat ) [user@archer2]$ pat_build jacobi Run the new executable with +pat appended as you would with the regular executable. This will generate performance data files with the suffix .xf (e.g. jacobi+pat+12265-1573s/xf-files ). Generate report data This .xt file contains the raw sampling data from the run and needs to be post processed to produce useful results. This is done using the pat_report tool which converts all the raw data into a summarised and readable form. : [user@archer2]$ pat_report jacobi+pat+12265-1573s Table 1: Profile by Function (limited entries shown) Samp% | Samp | Imb. | Imb. | Group | | Samp | Samp% | Function | | | | PE=HIDE 100.0% | 849.5 | -- | -- | Total 56.7% | 481.4 | -- | -- | MPI || 48.7% | 414.1 | 50.9 | 11.0% | MPI_Allreduce || 4.4% | 37.5 | 118.5 | 76.6% | MPI_Waitall || 3.0% | 25.2 | 44.8 | 64.5% | MPI_Isend | 29.9% | 253.9 | 55.1 | 18.0% | USER || 29.9% | 253.9 | 55.1 | 18.0% | main | 13.4% | 114.1 | -- | -- | ETC || 13.4% | 113.9 | 26.1 | 18.8% | __cray_memcpy_SNB |================================================== This report will generate two more files, one with the extension .ap2 which holds the same data as the .xf but in the post processed form. The other file has a .apa extension and is a text file with a suggested configuration for generating a traced experiment. The .ap2 file generated is used to view performance data graphically with the Cray Apprentice2 tool, and the latter is used for more detailed tracing experiments. The pat_report command is able to produce many different profile reports from the profile data. You can select a predefined report with the -O flag to pat_report . A selection of the most generally useful predefined report types are ca+src - Show the callers (bottom-up view) leading to the routines that have a high use in the report and include source code line numbers for the calls and time-consuming statements. load_balance - Show load-balance statistics for the high-use routines in the program. Parallel processes with minimum, maximum and median times for routines will be displayed. Only available with tracing experiments. mpi_callers - Show MPI message statistics. Only available with tracing experiments. [user@archer2]$ pat_report -O ca+src,load_balance jacobi+pat+12265-1573s Table 1: Profile by Function and Callers, with Line Numbers (limited entries shown) Samp% | Samp | Imb. | Imb. | Group | | Samp | Samp% | Function | | | | PE=HIDE 100.0% | 849.5 | -- | -- | Total --------------------------------------| 56.7% | 481.4 | MPI || 48.7% | 414.1 | MPI_Allreduce 3| | | main:jacobi.c:line.80 || 4.4% | 37.5 | MPI_Waitall 3| | | main:jacobi.c:line.73 || 3.0% | 25.2 | MPI_Isend ||| 1.6% | 13.2 | main:jacobi.c:line.65 3|| 1.4% | 12.0 | main:jacobi.c:line.69 | 29.9% | 253.9 | USER || 29.9% | 253.9 | main ||| 18.7% | 159.0 | main:jacobi.c:line.76 3|| 9.1% | 76.9 | main:jacobi.c:line.84 || 13.4% | 114.1 | ETC || 13.4% | 113.9 | __cray_memcpy_SNB 3| | | __cray_memcpy_SNB |======================================","title":"Sampling analysis"},{"location":"user-guide/profile/#tracing-analysis","text":"","title":"Tracing analysis"},{"location":"user-guide/profile/#automatic-program-analysis-apa","text":"We can produce a focused tracing experiment based on the results from the sampling experiment using pat_build with the .apa file produced during the sampling. [user@archer2]$ pat_build -O jacobi+pat+12265-1573s/build-options.apa This will produce a third binary with extension +apa . This binary should once again be run on the compute nodes and the name of the executable changed to jacobi+apa . As with the sampling analysis, a report can be produced using pat_report . [user@archer2]$ pat_report jacobi+apa+13955-1573t Table 1: Profile by Function Group and Function (limited entries shown) Time% | Time | Imb. | Imb. | Calls | Group | | Time | Time% | | Function | | | | | PE=HIDE 100.0% | 12.987762 | -- | -- | 1,387,544.9 | Total 44.9% | 5.831320 | -- | -- | 2.0 | USER || 44.9% | 5.831229 | 0.398671 | 6.4% | 1.0 | main | 29.2% | 3.789904 | -- | -- | 199,111.0 | MPI_SYNC || 29.2% | 3.789115 | 1.792050 | 47.3% | 199,109.0 | MPI_Allreduce(sync) | 25.9% | 3.366537 | -- | -- | 1,188,431.9 | MPI || 18.0% | 2.334765 | 0.164646 | 6.6% | 199,109.0 | MPI_Allreduce || 3.7% | 0.486714 | 0.882654 | 65.0% | 199,108.0 | MPI_Waitall || 3.3% | 0.428731 | 0.557342 | 57.0% | 395,104.9 | MPI_Isend |=========================================================================","title":"Automatic Program Analysis (APA)"},{"location":"user-guide/profile/#manual-program-analysis","text":"CrayPat allows you to manually choose your profiling preference. This is particularly useful if the APA mode does not meet your tracing analysis requirements. The entire program can be traced as a whole using -w : [user@archer2]$ pat_build -w jacobi Using -g a program can be instrumented to trace all function entry point references belonging to the trace function group tracegroup (mpi, libsci, lapack, scalapack, heap, etc) [user@archer2]$ pat_build -w -g mpi jacobi","title":"Manual Program Analysis"},{"location":"user-guide/profile/#dynamically-linked-binaries","text":"CrayPat allows you to profile un-instrumented, dynamically linked binaries with the pat_run utility. pat_run delivers profiling information for codes that cannot easily be rebuilt. To use pat_run : Load the perfotools-base module if it is not already loaded module load perftools-base Run your application normally including the pat_run command rigth after your srun options srun [srun-options] pat_run [pat_run-options] program [program-options] Use pat_report to examine any data collected during the execution of your application. [user@archer2]$ pat_report jacobi+pat+12265-1573s Some useful pat_run options are: -w Collect data by tracing. -g Trace functions belonging to group names. See the -g option in pat_build(1) for a list of valid tracegroup values. -r Generate a text report upon successful execution.","title":"Dynamically-linked binaries"},{"location":"user-guide/profile/#further-help_1","text":"CrayPat User Guide","title":"Further help"},{"location":"user-guide/profile/#cray-apprentice2","text":"Cray Apprentice2 is an optional GUI tool that is used to visualize and manipulate the performance analysis data captured during program execution. Cray Apprentice2 can be run either on the Cray system or, optionally, on a standalone Linux desktop machine. Cray Apprentice2 can display a wide variety of reports and graphs, depending on the type of program being analyzed, the way in which the program was instrumented for data capture, and the data that was collected during program execution. You will need to use CrayPat first, to instrument your program and capture performance analysis data, and then use Cray Apprentice2 to visualize and explore the resulting data files. The number and appearance of the reports that can be generated using Cray Apprentice2 is determined by the kind and quantity of data captured during program execution, which in turn is determined by the way in which the program was instrumented and the environment variables in effect at the time of program execution. For example, changing the PAT_RT_SUMMARY environment variable to 0 before executing the instrumented program nearly doubles the number of reports available when analyzing the resulting data in Cray Apprentice2. export PAT_RT_SUMMARY=0 To use Cray Apprentice2 ( app2 ), load perftools-base module if it is not already loaded module load perftools-base then open the Cray Apprentice2 data ( .ap2 ) generated during the instrumentation phase [user@archer2]$ app2 jacobi+pat+12265-1573s/datafile.ap2","title":"Cray Apprentice2"},{"location":"user-guide/profile/#hardware-performance-counters","text":"","title":"Hardware Performance Counters"},{"location":"user-guide/python/","text":"Using Python Python for general users Cray Python 3 distribution Python 3 on ARCHER2 is provided by Cray. The central installation provides many of the most common packages used for scientific computation and data analysis. These include: numpy and scipy - built against Cray LibSci mpi4py - built against Cray MPT dask The Python 3 module can be loaded (either on the front-end or in a submission script) using: module load cray-python Adding your own packages If the packages you require are not included in the central Python distribution, further packages can easily be built on top using pip. This can be done using: pip install --user <package_name> This uses the \"-\\-user\" flag to ensure the packages are installed in your user directory. This means that you can have your own Python environment that is independent of the central installation. conda This section on the conda tool is adapted from the NERSC Python documentation at https://docs.nersc.gov/programming/high-level-environments/python/ . Creating conda environments The conda tool allows you to build your own custom Python installation through \"environments\". First, create a conda environment using conda create . Specify a name for your environment using the \"-n\" flag, and the version of the Python interpreter you want installed. For example, the following will create a Python 3.6 environment called \"myenv\": conda create -n myenv python=3.6 You will then be asked to confirm the package managements steps that will be taken, along with the installation location. Activating conda environments There are two options for activating a conda environments: source activate and conda activate . source activate is the only option for versions of conda prior to 4.6. You can activate an environment with the name \"myenv\" with the command: source activate myenv and then deactivate it with: source deactivate conda activate is available in conda 4.6 and later. It can be more complex to use than source activate , but has some advantages. Before running conda activate for the first time, first run the command conda init . This sets the current Python environment as the default. It does this by adding lines to your .bashrc file that will be run at login. (These lines are enclosed by the lines # >>> conda initialize >>> and # <<< conda initialize <<< , and can be removed or edited manually if needed.) Having set your default environment, your custom environments can be activated using: : conda activate myenv and deactivated using: : conda deactivate Installing Packages conda can also be used to find and install packages into your environments. For example, the following can be used to find and then install a package (in this case, scipy): conda search scipy conda install scipy Example Python submission script #!/bin/bash --login #SBATCH --name=python_test #SBATCH --nodes=1 #SBATCH --tasks-per-node=1 #SBATCH --cpus-per-task=1 #SBATCH --time=00:10:00 # Replace [budget code] below with your project code (e.g. t01) #SBATCH --account=[budget code] # Load the Python module module load cray-python # Run your Python progamme python python_test.py mpi4py Programmes that have been parallelised with mpi4py can be run on multiple processors on ARCHER2. A sample submission script is given below. The primary difference from the Python submission script in the previous section is that we must run the programme using srun python my_prog.py instead of python my_prog,py . Failing to do so will cause a segmentation fault in your programme when it reaches the line from mpi4py import MPI . #!/bin/bash --login # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=mpi4py_test #SBATCH --nodes=1 #SBATCH --tasks-per-node=2 #SBATCH --cpus-per-task=1 #SBATCH --time=0:10:0 # Replace [budget code] below with your budget code (e.g. t01) #SBATCH --account=[budget code] # Load the Python module module load cray-python # Run your Python programme # Note that srun MUST be used to wrap the call to python, otherwise an error # will occur srun python mpi4py_test.py","title":"Python"},{"location":"user-guide/python/#using-python","text":"","title":"Using Python"},{"location":"user-guide/python/#python-for-general-users","text":"","title":"Python for general users"},{"location":"user-guide/python/#cray-python-3-distribution","text":"Python 3 on ARCHER2 is provided by Cray. The central installation provides many of the most common packages used for scientific computation and data analysis. These include: numpy and scipy - built against Cray LibSci mpi4py - built against Cray MPT dask The Python 3 module can be loaded (either on the front-end or in a submission script) using: module load cray-python","title":"Cray Python 3 distribution"},{"location":"user-guide/python/#adding-your-own-packages","text":"If the packages you require are not included in the central Python distribution, further packages can easily be built on top using pip. This can be done using: pip install --user <package_name> This uses the \"-\\-user\" flag to ensure the packages are installed in your user directory. This means that you can have your own Python environment that is independent of the central installation.","title":"Adding your own packages"},{"location":"user-guide/python/#conda","text":"This section on the conda tool is adapted from the NERSC Python documentation at https://docs.nersc.gov/programming/high-level-environments/python/ .","title":"conda"},{"location":"user-guide/python/#creating-conda-environments","text":"The conda tool allows you to build your own custom Python installation through \"environments\". First, create a conda environment using conda create . Specify a name for your environment using the \"-n\" flag, and the version of the Python interpreter you want installed. For example, the following will create a Python 3.6 environment called \"myenv\": conda create -n myenv python=3.6 You will then be asked to confirm the package managements steps that will be taken, along with the installation location.","title":"Creating conda environments"},{"location":"user-guide/python/#activating-conda-environments","text":"There are two options for activating a conda environments: source activate and conda activate . source activate is the only option for versions of conda prior to 4.6. You can activate an environment with the name \"myenv\" with the command: source activate myenv and then deactivate it with: source deactivate conda activate is available in conda 4.6 and later. It can be more complex to use than source activate , but has some advantages. Before running conda activate for the first time, first run the command conda init . This sets the current Python environment as the default. It does this by adding lines to your .bashrc file that will be run at login. (These lines are enclosed by the lines # >>> conda initialize >>> and # <<< conda initialize <<< , and can be removed or edited manually if needed.) Having set your default environment, your custom environments can be activated using: : conda activate myenv and deactivated using: : conda deactivate","title":"Activating conda environments"},{"location":"user-guide/python/#installing-packages","text":"conda can also be used to find and install packages into your environments. For example, the following can be used to find and then install a package (in this case, scipy): conda search scipy conda install scipy","title":"Installing Packages"},{"location":"user-guide/python/#example-python-submission-script","text":"#!/bin/bash --login #SBATCH --name=python_test #SBATCH --nodes=1 #SBATCH --tasks-per-node=1 #SBATCH --cpus-per-task=1 #SBATCH --time=00:10:00 # Replace [budget code] below with your project code (e.g. t01) #SBATCH --account=[budget code] # Load the Python module module load cray-python # Run your Python progamme python python_test.py","title":"Example Python submission script"},{"location":"user-guide/python/#mpi4py","text":"Programmes that have been parallelised with mpi4py can be run on multiple processors on ARCHER2. A sample submission script is given below. The primary difference from the Python submission script in the previous section is that we must run the programme using srun python my_prog.py instead of python my_prog,py . Failing to do so will cause a segmentation fault in your programme when it reaches the line from mpi4py import MPI . #!/bin/bash --login # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=mpi4py_test #SBATCH --nodes=1 #SBATCH --tasks-per-node=2 #SBATCH --cpus-per-task=1 #SBATCH --time=0:10:0 # Replace [budget code] below with your budget code (e.g. t01) #SBATCH --account=[budget code] # Load the Python module module load cray-python # Run your Python programme # Note that srun MUST be used to wrap the call to python, otherwise an error # will occur srun python mpi4py_test.py","title":"mpi4py"},{"location":"user-guide/scheduler/","text":"Running jobs on ARCHER2 Warning The ARCHER2 Service is not yet available. This documentation is in development. As with most HPC services, ARCHER2 uses a scheduler to manage access to resources and ensure that the thousands of different users of system are able to share the system and all get access to the resources they require. ARCHER2 uses the Slurm software to schedule jobs. Writing a submission script is typically the most convenient way to submit your job to the scheduler. Example submission scripts (with explanations) for the most common job types are provided below. Interactive jobs are also available and can be particularly useful for developing and debugging applications. More details are available below. Hint If you have any questions on how to run jobs on ARCHER2 do not hesitate to contact the ARCHER2 Service Desk . You typically interact with Slurm by issuing Slurm commands from the login nodes (to submit, check and cancel jobs), and by specifying Slurm directives that describe the resources required for your jobs in job submission scripts. Basic Slurm commands There are three key commands used to interact with the Slurm on the command line: sinfo - Get information on the partitions and resources available sbatch jobscript.slurm - Submit a job submission script (in this case called: jobscript.slurm ) to the scheduler squeue - Get the current status of jobs submitted to the scheduler scancel 12345 - Cancel a job (in this case with the job ID 12345 ) We cover each of these commands in more detail below. sinfo : information on resources sinfo is used to query information about available resources and partitions. Without any options, sinfo lists the status of all resources and partitions, e.g. sinfo PARTITION AVAIL TIMELIMIT NODES STATE NODELIST standard up 2-00:00:00 1 fail* cn580 standard up 2-00:00:00 128 down$ cn[96,579,793,814,1025-1044,1081-1088] standard up 2-00:00:00 26 maint cn[27,93-95,206,232,310,492,568,577-578,585-588,813,815-816,818,846,889,921-924,956] standard up 2-00:00:00 2 fail cn[274,871] standard up 2-00:00:00 4 down* cn[528,614,637,845] standard up 2-00:00:00 1034 alloc cn[1-26,28-38,40-58,62-86,88-92,97-174,176-205,207-231,233-273,275-309,311-333,335-341,344-371,373-376,378-413,415-452,454-489,493-513,515-527,529-532,535-539,541-550,554-561,563-567,569,572-576,581-584,589-595,598-601,603-613,615,617-620,623-631,633-636,638-647,651-659,661-678,680-687,690-695,697-716,718-736,738-775,777-790,792,794-812,817,819-844,847-852,854-870,872-888,890-920,925-955,957-977,980-1014,1016-1020,1023-1024,1045,1047-1070,1072-1080,1089-1105,1107-1152] standard up 2-00:00:00 26 idle cn[61,490-491,540,551-552,562,570,596,602,621,632,648-650,660,688-689,696,853,978-979,1015,1021-1022,1071] sbatch : submitting jobs sbatch is used to submit a job script to the job submission system. The script will typically contain one or more srun commands to launch parallel tasks. When you submit the job, the scheduler provides the job ID, which is used to identify this job in other Slurm commands and when looking at resource usage in SAFE. sbatch test-job.slurm Submitted batch job 12345 squeue : monitoring jobs squeue without any options or arguments shows the current status of all jobs known to the scheduler. For example: squeue will list all jobs on ARCHER2. The output of this is often overwhelmingly large. You can restrict the output to just your jobs by adding the -u $USER option: squeue -u $USER scancel : deleting jobs scancel is used to delete a jobs from the scheduler. If the job is waiting to run it is simply cancelled, if it is a running job then it is stopped immediately. You need to provide the job ID of the job you wish to cancel/stop. For example: scancel 12345 will cancel (if waiting) or stop (if running) the job with ID 12345 . Resource Limits There are different resource limits on ARCHER2 for different purposes. Note Details on the resource limits will be added when the ARCHER2 system is available. Troubleshooting Slurm error messages Note More information on common error messages will be added when the ARCHER2 system is available. Slurm queued reasons Note Explanations of the reasons for jobs being queued and not running will be added when the ARCHER2 system is available. Output from Slurm jobs Slurm places standard output (STDOUT) and standard error (STDERR) for each job in the file slurm_<JobID>.out . This file appears in the job's working directory once your job starts running. Note This file is plain text and can contain useful information to help debugging if a job is not working as expected. The ARCHER2 Service Desk team will often ask you to provide the contents of this file if oyu contact them for help with issues. Specifying resources in job scripts You specify the resources you require for your job using directives at the top of your job submission script using lines that start with the directive #SBATCH . Note Options provided using #SBATCH directives can also be specified as command line options to srun . If you do not specify any options, then the default for each option will be applied. As a minimum, all job submissions must specify the budget that they wish to charge the job too with the option: --account=<budgetID> your budget ID is usually something like t01 or t01-test . You can see which budget codes you can charge to in SAFE. Other common options that are used are: --time=<hh:mm:ss> the maximum walltime for your job. e.g. For a 6.5 hour walltime, you would use --time=6:30:0 . --job-name=<jobjob-name> set a job-name for the job to help identify it in Slurm command output. In addition, parallel jobs will also need to specify how many nodes, parallel processes and threads they require. --nodes=<nodes> the number of nodes to use for the job. --tasks-per-node=<processes per node> the number of parallel processes (e.g. MPI ranks) per node. --cpus-per-task=1 if you are using parallel processes only with no threading then you should set the number of CPUs (cores) per parallel process to 1. Note: if you are using threading (e.g. with OpenMP) then you will need to change this option as described below. For parallel jobs that use threading (e.g. OpenMP), you will also need to change the --cpus-per-task option. --cpus-per-task=<threads per task> the number of threads per parallel process (e.g. number of OpenMP threads per MPI task for hybrid MPI/OpenMP jobs). Note: you must also set the OMP_NUM_THREADS environment variable if using OpenMP in your job. Note For parallel jobs, ARCHER2 operates in a node exclusive way. This means that you are assigned resources in the units of full compute nodes for your jobs ( i.e. 128 cores) and that no other user can share those compute nodes with you. Hence, the minimum amount of resource you can request for a parallel job is 1 node (or 128 cores). srun : Launching parallel jobs If you are running parallel jobs, your job submission script should contain one or more srun commands to launch the parallel executable across the compute nodes. Warning To ensure that processes and threads are correctly mapped (or pinned ) to cores, you should always specify --cpu-bind=cores option to srun . Example job submission scripts A subset of example job submission scripts are included in full below. You can also download these examples at: Example: job submission script for MPI parallel job A simple MPI job submission script to submit a job using 4 compute nodes and 128 MPI ranks per node for 20 minutes would look like: #!/bin/bash # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=Example_MPI_Job #SBATCH --time=0:20:0 #SBATCH --nodes=4 #SBATCH --tasks-per-node=128 #SBATCH --cpus-per-task=1 # Replace [budget code] below with your budget code (e.g. t01) #SBATCH --account=[budget code] # Set the number of threads to 1 # This prevents any threaded system libraries from automatically # using threading. export OMP_NUM_THREADS=1 # Launch the parallel job # Using 1024 MPI processes and 128 MPI processes per node # srun picks up the distribution from the sbatch options srun --cpu-bind=cores ./my_mpi_executable.x This will run your executable \"my_mpi_executable.x\" in parallel on 1024 MPI processes using 4 nodes (128 cores per node, i.e. not using hyper-threading). Slurm will allocate 4 nodes to your job and srun will place 128 MPI processes on each node (one per physical core). See above for a more detailed discussion of the different sbatch options Example: job submission script for MPI+OpenMP (mixed mode) parallel job Mixed mode codes that use both MPI (or another distributed memory parallel model) and OpenMP should take care to ensure that the shared memory portion of the process/thread placement does not span more than one node. This means that the number of shared memory threads should be a factor of 128. In the example below, we are using 4 nodes for 6 hours. There are 32 MPI processes in total (8 MPI processes per node) and 16 OpenMP threads per MPI process. This results in all 128 physical cores per node being used. Note Note the use of the export OMP_PLACES=cores environment option and the --hint=nomultithread and --distribution=block:block options to srun to generate the correct pinning. #!/bin/bash # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=Example_MPI_Job #SBATCH --time=0:20:0 #SBATCH --nodes=4 #SBATCH --ntasks=32 #SBATCH --tasks-per-node=8 #SBATCH --cpus-per-task=16 # Replace [budget code] below with your project code (e.g. t01) #SBATCH --account=[budget code] # Set the number of threads to 16 and specify placement # There are 16 OpenMP threads per MPI process # We want one thread per physical core export OMP_NUM_THREADS=16 export OMP_PLACES=cores # Launch the parallel job # Using 32 MPI processes # 8 MPI processes per node # 16 OpenMP threads per MPI process # Additional srun options to pin one thread per physical core srun --hint=nomultithread --distribution=block:block ./my_mixed_executable.x arg1 arg2 Job arrays The Slurm job scheduling system offers the job array concept, for running collections of almost-identical jobs. For example, running the same program several times with different arguments or input data. Each job in a job array is called a subjob . The subjobs of a job array can be submitted and queried as a unit, making it easier and cleaner to handle the full set, compared to individual jobs. All subjobs in a job array are started by running the same job script. The job script also contains information on the number of jobs to be started, and Slurm provides a subjob index which can be passed to the individual subjobs or used to select the input data per subjob. Job script for a job array As an example, the following script runs 56 subjobs, with the subjob index as the only argument to the executable. Each subjob requests a single node and uses all 128 cores on the node by placing 1 MPI process per core and specifies 4 hours maximum runtime per subjob: #!/bin/bash # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=Example_Array_Job #SBATCH --time=0:20:0 #SBATCH --nodes=4 #SBATCH --tasks-per-node=128 #SBATCH --cpus-per-task=1 #SBATCH --array=0-55 # Replace [budget code] below with your budget code (e.g. t01) #SBATCH --account=[budget code] # Set the number of threads to 1 # This prevents any threaded system libraries from automatically # using threading. export OMP_NUM_THREADS=1 srun --cpu-bind=cores /path/to/exe $Slurm_ARRAY_TASK_ID Submitting a job array Job arrays are submitted using sbatch in the same way as for standard jobs: sbatch job_script.pbs Job chaining Job dependencies can be used to construct complex pipelines or chain together long simulations requiring multiple steps. Note The --parsable option to sbatch can simplify working with job dependencies. It returns the job ID in a format that can be used as the input to other commands. For example: jobid=$(sbatch --parsable first_job.sh) sbatch --dependency=afterok:$jobid second_job.sh or for a longer chain: jobid1=$(sbatch --parsable first_job.sh) jobid2=$(sbatch --parsable --dependency=afterok:$jobid1 second_job.sh) jobid3=$(sbatch --parsable --dependency=afterok:$jobid1 third_job.sh) sbatch --dependency=afterok:$jobid2,afterok:$jobid3 last_job.sh Interactive Jobs: salloc When you are developing or debugging code you often want to run many short jobs with a small amount of editing the code between runs. This can be achieved by using the login nodes to run MPI but you may want to test on the compute nodes (e.g. you may want to test running on multiple nodes across the high performance interconnect). One of the best ways to achieve this on ARCHER2 is to use interactive jobs. An interactive job allows you to issue srun commands directly from the command line without using a job submission script, and to see the output from your program directly in the terminal. You use the salloc command to reserve compute nodes for interactive jobs. To submit a request for an interactive job reserving 8 nodes (1024 physical cores) for 1 hour you would issue the following qsub command from the command line: salloc --nodes=8 --tasks-per-node=128 --cpus-per-task=1 --time=1:0:0 --account=[budget code] When you submit this job your terminal will display something like: salloc: Granted job allocation 24236 salloc: Waiting for resource configuration salloc: Nodes nid000002 are ready for job It may take some time for your interactive job to start. Once it runs you will enter a standard interactive terminal session. Whilst the interactive session lasts you will be able to run parallel jobs on the compute nodes by issuing the srun --cpu-bind=cores command directly at your command prompt using the same syntax as you would inside a job script. The maximum number of nodes you can use is limited by resources requested in the salloc command. If you know you will be doing a lot of intensive debugging you may find it useful to request an interactive session lasting the expected length of your working session, say a full day. Your session will end when you hit the requested walltime. If you wish to finish before this you should use the exit command - this will return you to your prompt before you issued the salloc command. Reservations The mechanism for submitting reservations on ARCHER2 has yet to be specified. Best practices for job submission This guidance is adapted from the advice provided by NERSC Do not run production jobs in /home As a general best practice, users should run production runs from the /work file systems rather than the /home file systems. The /home file system is designed for permanent and relatively small storage. It is not tuned to perform well for parallel jobs and large amounts of I/O. Home is perfect for storing files such as source codes and shell scripts. Please note that while building software in /home is generally OK, it is best to install dynamic libraries and binaries that are used on compute nodes on the /work file systems for best performance. The /work file systems are designed for large, temporary storage, particularly for I/O from parallel jobs running on the compute nodes and large scale data analysis (although the solid state storage may provide better performance in particular scenarios). Running jobs on the /work file systems also helps to improve the responsiveness of the /home file systems for all users. Time Limits Due to backfill scheduling, short and variable-length jobs generally start quickly resulting in much better job throughput. You can specify a minimum time for your job with the --time-min option to SBATCH: #SBATCH --time-min=<lower_bound> #SBATCH --time=<upper_bound> Within your job script, you can get the time remaining in the job with squeue -h -j ${Slurm_JOBID} -o %L to allow you to deal with potentially varying runtimes when using this option. Long Running Jobs Simulations which must run for a long period of time achieve the best throughput when composed of many small jobs using a checkpoint and restart method chained together (see above for how to chain jobs together). However, this method does occur a startup and shutdown overhead for each job as the state is saved and loaded so you should experiment to find the best balance between runtime (long runtimes minimise the checkpoint/restart overheads) and throughput (short runtimes maximise throughput). I/O performance Large Jobs Large jobs may take longer to start up. The sbcast command is recommended for large jobs requesting over 1500 MPI tasks. By default, Slurm reads the executable on the allocated compute nodes from the location where it is installed; this may take long time when the file system (where the executable resides) is slow or busy. The sbcast command, the executable can be copied to the /tmp directory on each of the compute nodes. Since /tmp is part of the memory on the compute nodes, it can speed up the job startup time. sbcast --compress=lz4 /path/to/exe /tmp/exe srun /tmp/exe Network Locality For jobs which are sensitive to interconnect (MPI) performance and utilize less than or equal to 256 nodes it is possible to request that all nodes are in a single Slingshot dragonfly group. Slurm has a concept of \"switches\" which on ARCHER2 are configured to map to Slingshot groups (there are 256 nodes per group). Since this places an additional constraint on the scheduler a maximum time to wait for the requested topology can be specified. For example: sbatch --switches=1@60 job.sh`` Process Placement Several mechanisms exist to control process placement on ARCHER2. Application performance can depend strongly on placement depending on the communication pattern and other computational characteristics. Default The default is to place MPI tasks sequentially on nodes until the maximum number of tasks is reached: salloc --nodes=8 --tasks-per-node=2 --cpus-per-task=1 --time=0:10:0 --account=t01 salloc: Granted job allocation 24236 salloc: Waiting for resource configuration salloc: Nodes cn13 are ready for job module load xthi export OMP_NUM_THREADS=1 srun --cpu-bind=cores xthi Hello from rank 0, thread 0, on nid000001. (core affinity = 0,128) Hello from rank 1, thread 0, on nid000001. (core affinity = 16,144) Hello from rank 2, thread 0, on nid000002. (core affinity = 0,128) Hello from rank 3, thread 0, on nid000002. (core affinity = 16,144) Hello from rank 4, thread 0, on nid000003. (core affinity = 0,128) Hello from rank 5, thread 0, on nid000003. (core affinity = 16,144) Hello from rank 6, thread 0, on nid000004. (core affinity = 0,128) Hello from rank 7, thread 0, on nid000004. (core affinity = 16,144) Hello from rank 8, thread 0, on nid000005. (core affinity = 0,128) Hello from rank 9, thread 0, on nid000005. (core affinity = 16,144) Hello from rank 10, thread 0, on nid000006. (core affinity = 0,128) Hello from rank 11, thread 0, on nid000006. (core affinity = 16,144) Hello from rank 12, thread 0, on nid000007. (core affinity = 0,128) Hello from rank 13, thread 0, on nid000007. (core affinity = 16,144) Hello from rank 14, thread 0, on nid000008. (core affinity = 0,128) Hello from rank 15, thread 0, on nid000008. (core affinity = 16,144) MPICH_RANK_REORDER_METHOD The MPICH_RANK_REORDER_METHOD environment variable is used to specify other types of MPI task placement. For example, setting it to 0 results in a round-robin placement: salloc --nodes=8 --tasks-per-node=2 --cpus-per-task=1 --time=0:10:0 --account=t01 salloc: Granted job allocation 24236 salloc: Waiting for resource configuration salloc: Nodes cn13 are ready for job module load xthi export OMP_NUM_THREADS=1 export MPICH_RANK_REORDER_METHOD=0 srun --cpu-bind=cores xthi Hello from rank 0, thread 0, on nid000001. (core affinity = 0,128) Hello from rank 1, thread 0, on nid000002. (core affinity = 0,128) Hello from rank 2, thread 0, on nid000003. (core affinity = 0,128) Hello from rank 3, thread 0, on nid000004. (core affinity = 0,128) Hello from rank 4, thread 0, on nid000005. (core affinity = 0,128) Hello from rank 5, thread 0, on nid000006. (core affinity = 0,128) Hello from rank 6, thread 0, on nid000007. (core affinity = 0,128) Hello from rank 7, thread 0, on nid000008. (core affinity = 0,128) Hello from rank 8, thread 0, on nid000001. (core affinity = 16,144) Hello from rank 9, thread 0, on nid000002. (core affinity = 16,144) Hello from rank 10, thread 0, on nid000003. (core affinity = 16,144) Hello from rank 11, thread 0, on nid000004. (core affinity = 16,144) Hello from rank 12, thread 0, on nid000005. (core affinity = 16,144) Hello from rank 13, thread 0, on nid000006. (core affinity = 16,144) Hello from rank 14, thread 0, on nid000007. (core affinity = 16,144) Hello from rank 15, thread 0, on nid000008. (core affinity = 16,144) There are other modes available with the MPICH_RANK_REORDER_METHOD environment variable, including one which lets the user provide a file called MPICH_RANK_ORDER which contains a list of each task's placement on each node. These options are described in detail in the intro_mpi man page. grid_order For MPI applications which perform a large amount of nearest-neighbor communication, e.g., stencil-based applications on structured grids, Cray provides a tool in the perftools-base module called grid_order which can generate a MPICH_RANK_ORDER file automatically by taking as parameters the dimensions of the grid, core count, etc. For example, to place MPI tasks in row-major order on a Cartesian grid of size $(4, 4, 4)$, using 32 tasks per node: module load perftools-base grid_order -R -c 32 -g 4,4,4 # grid_order -R -Z -c 32 -g 4,4,4 # Region 3: 0,0,1 (0..63) 0,1,2,3,16,17,18,19,32,33,34,35,48,49,50,51,4,5,6,7,20,21,22,23,36,37,38,39,52,53,54,55 8,9,10,11,24,25,26,27,40,41,42,43,56,57,58,59,12,13,14,15,28,29,30,31,44,45,46,47,60,61,62,63 One can then save this output to a file called MPICH_RANK_ORDER and then set MPICH_RANK_REORDER_METHOD=3 before running the job, which tells Cray MPI to read the MPICH_RANK_ORDER file to set the MPI task placement. For more information, please see the man page man grid_order (available when the perftools-base module is loaded). Huge pages Huge pages are virtual memory pages which are bigger than the default page size of 4K bytes. Huge pages can improve memory performance for common access patterns on large data sets since it helps to reduce the number of virtual to physical address translations when compared to using the default 4KB. To use huge pages for an application (with the 2 MB huge pages as an example): module load craype-hugepages2M cc -o mycode.exe mycode.c And also load the same huge pages module at runtime. Warning Due to the huge pages memory fragmentation issue, applications may get Cannot allocate memory warnings or errors when there are not enough hugepages on the compute node, such as: : libhugetlbfs [nid0000xx:xxxxx]: WARNING: New heap segment map at 0x10000000 failed: Cannot allocate memory`` By default, The verbosity level of libhugetlbfs HUGETLB_VERBOSE is set to 0 on ARCHER2 to surpress debugging messages. Users can adjust this value to obtain more information on huge pages use. When to Use Huge Pages For MPI applications, map the static data and/or heap onto huge pages. For an application which uses shared memory, which needs to be concurrently registered with the high speed network drivers for remote communication. For SHMEM applications, map the static data and/or private heap onto huge pages. For applications written in Unified Parallel C, Coarray Fortran, and other languages based on the PGAS programming model, map the static data and/or private heap onto huge pages. For an application doing heavy I/O. To improve memory performance for common access patterns on large data sets. When to Avoid Huge Pages Applications sometimes consist of many steering programs in addition to the core application. Applying huge page behavior to all processes would not provide any benefit and would consume huge pages that would otherwise benefit the core application. The runtime environment variable HUGETLB_RESTRICT_EXE can be used to specify the susbset of the programs to use hugepages. For certain applications if using hugepages either causes issues or slows down performance. One such example is that when an application forks more subprocesses (such as pthreads) and these threads allocate memory, the newly allocated memory are the default 4 KB pages.","title":"Scheduler"},{"location":"user-guide/scheduler/#running-jobs-on-archer2","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. As with most HPC services, ARCHER2 uses a scheduler to manage access to resources and ensure that the thousands of different users of system are able to share the system and all get access to the resources they require. ARCHER2 uses the Slurm software to schedule jobs. Writing a submission script is typically the most convenient way to submit your job to the scheduler. Example submission scripts (with explanations) for the most common job types are provided below. Interactive jobs are also available and can be particularly useful for developing and debugging applications. More details are available below. Hint If you have any questions on how to run jobs on ARCHER2 do not hesitate to contact the ARCHER2 Service Desk . You typically interact with Slurm by issuing Slurm commands from the login nodes (to submit, check and cancel jobs), and by specifying Slurm directives that describe the resources required for your jobs in job submission scripts.","title":"Running jobs on ARCHER2"},{"location":"user-guide/scheduler/#basic-slurm-commands","text":"There are three key commands used to interact with the Slurm on the command line: sinfo - Get information on the partitions and resources available sbatch jobscript.slurm - Submit a job submission script (in this case called: jobscript.slurm ) to the scheduler squeue - Get the current status of jobs submitted to the scheduler scancel 12345 - Cancel a job (in this case with the job ID 12345 ) We cover each of these commands in more detail below.","title":"Basic Slurm commands"},{"location":"user-guide/scheduler/#sinfo-information-on-resources","text":"sinfo is used to query information about available resources and partitions. Without any options, sinfo lists the status of all resources and partitions, e.g. sinfo PARTITION AVAIL TIMELIMIT NODES STATE NODELIST standard up 2-00:00:00 1 fail* cn580 standard up 2-00:00:00 128 down$ cn[96,579,793,814,1025-1044,1081-1088] standard up 2-00:00:00 26 maint cn[27,93-95,206,232,310,492,568,577-578,585-588,813,815-816,818,846,889,921-924,956] standard up 2-00:00:00 2 fail cn[274,871] standard up 2-00:00:00 4 down* cn[528,614,637,845] standard up 2-00:00:00 1034 alloc cn[1-26,28-38,40-58,62-86,88-92,97-174,176-205,207-231,233-273,275-309,311-333,335-341,344-371,373-376,378-413,415-452,454-489,493-513,515-527,529-532,535-539,541-550,554-561,563-567,569,572-576,581-584,589-595,598-601,603-613,615,617-620,623-631,633-636,638-647,651-659,661-678,680-687,690-695,697-716,718-736,738-775,777-790,792,794-812,817,819-844,847-852,854-870,872-888,890-920,925-955,957-977,980-1014,1016-1020,1023-1024,1045,1047-1070,1072-1080,1089-1105,1107-1152] standard up 2-00:00:00 26 idle cn[61,490-491,540,551-552,562,570,596,602,621,632,648-650,660,688-689,696,853,978-979,1015,1021-1022,1071]","title":"sinfo: information on resources"},{"location":"user-guide/scheduler/#sbatch-submitting-jobs","text":"sbatch is used to submit a job script to the job submission system. The script will typically contain one or more srun commands to launch parallel tasks. When you submit the job, the scheduler provides the job ID, which is used to identify this job in other Slurm commands and when looking at resource usage in SAFE. sbatch test-job.slurm Submitted batch job 12345","title":"sbatch: submitting jobs"},{"location":"user-guide/scheduler/#squeue-monitoring-jobs","text":"squeue without any options or arguments shows the current status of all jobs known to the scheduler. For example: squeue will list all jobs on ARCHER2. The output of this is often overwhelmingly large. You can restrict the output to just your jobs by adding the -u $USER option: squeue -u $USER","title":"squeue: monitoring jobs"},{"location":"user-guide/scheduler/#scancel-deleting-jobs","text":"scancel is used to delete a jobs from the scheduler. If the job is waiting to run it is simply cancelled, if it is a running job then it is stopped immediately. You need to provide the job ID of the job you wish to cancel/stop. For example: scancel 12345 will cancel (if waiting) or stop (if running) the job with ID 12345 .","title":"scancel: deleting jobs"},{"location":"user-guide/scheduler/#resource-limits","text":"There are different resource limits on ARCHER2 for different purposes. Note Details on the resource limits will be added when the ARCHER2 system is available.","title":"Resource Limits"},{"location":"user-guide/scheduler/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"user-guide/scheduler/#slurm-error-messages","text":"Note More information on common error messages will be added when the ARCHER2 system is available.","title":"Slurm error messages"},{"location":"user-guide/scheduler/#slurm-queued-reasons","text":"Note Explanations of the reasons for jobs being queued and not running will be added when the ARCHER2 system is available.","title":"Slurm queued reasons"},{"location":"user-guide/scheduler/#output-from-slurm-jobs","text":"Slurm places standard output (STDOUT) and standard error (STDERR) for each job in the file slurm_<JobID>.out . This file appears in the job's working directory once your job starts running. Note This file is plain text and can contain useful information to help debugging if a job is not working as expected. The ARCHER2 Service Desk team will often ask you to provide the contents of this file if oyu contact them for help with issues.","title":"Output from Slurm jobs"},{"location":"user-guide/scheduler/#specifying-resources-in-job-scripts","text":"You specify the resources you require for your job using directives at the top of your job submission script using lines that start with the directive #SBATCH . Note Options provided using #SBATCH directives can also be specified as command line options to srun . If you do not specify any options, then the default for each option will be applied. As a minimum, all job submissions must specify the budget that they wish to charge the job too with the option: --account=<budgetID> your budget ID is usually something like t01 or t01-test . You can see which budget codes you can charge to in SAFE. Other common options that are used are: --time=<hh:mm:ss> the maximum walltime for your job. e.g. For a 6.5 hour walltime, you would use --time=6:30:0 . --job-name=<jobjob-name> set a job-name for the job to help identify it in Slurm command output. In addition, parallel jobs will also need to specify how many nodes, parallel processes and threads they require. --nodes=<nodes> the number of nodes to use for the job. --tasks-per-node=<processes per node> the number of parallel processes (e.g. MPI ranks) per node. --cpus-per-task=1 if you are using parallel processes only with no threading then you should set the number of CPUs (cores) per parallel process to 1. Note: if you are using threading (e.g. with OpenMP) then you will need to change this option as described below. For parallel jobs that use threading (e.g. OpenMP), you will also need to change the --cpus-per-task option. --cpus-per-task=<threads per task> the number of threads per parallel process (e.g. number of OpenMP threads per MPI task for hybrid MPI/OpenMP jobs). Note: you must also set the OMP_NUM_THREADS environment variable if using OpenMP in your job. Note For parallel jobs, ARCHER2 operates in a node exclusive way. This means that you are assigned resources in the units of full compute nodes for your jobs ( i.e. 128 cores) and that no other user can share those compute nodes with you. Hence, the minimum amount of resource you can request for a parallel job is 1 node (or 128 cores).","title":"Specifying resources in job scripts"},{"location":"user-guide/scheduler/#srun-launching-parallel-jobs","text":"If you are running parallel jobs, your job submission script should contain one or more srun commands to launch the parallel executable across the compute nodes. Warning To ensure that processes and threads are correctly mapped (or pinned ) to cores, you should always specify --cpu-bind=cores option to srun .","title":"srun: Launching parallel jobs"},{"location":"user-guide/scheduler/#example-job-submission-scripts","text":"A subset of example job submission scripts are included in full below. You can also download these examples at:","title":"Example job submission scripts"},{"location":"user-guide/scheduler/#example-job-submission-script-for-mpi-parallel-job","text":"A simple MPI job submission script to submit a job using 4 compute nodes and 128 MPI ranks per node for 20 minutes would look like: #!/bin/bash # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=Example_MPI_Job #SBATCH --time=0:20:0 #SBATCH --nodes=4 #SBATCH --tasks-per-node=128 #SBATCH --cpus-per-task=1 # Replace [budget code] below with your budget code (e.g. t01) #SBATCH --account=[budget code] # Set the number of threads to 1 # This prevents any threaded system libraries from automatically # using threading. export OMP_NUM_THREADS=1 # Launch the parallel job # Using 1024 MPI processes and 128 MPI processes per node # srun picks up the distribution from the sbatch options srun --cpu-bind=cores ./my_mpi_executable.x This will run your executable \"my_mpi_executable.x\" in parallel on 1024 MPI processes using 4 nodes (128 cores per node, i.e. not using hyper-threading). Slurm will allocate 4 nodes to your job and srun will place 128 MPI processes on each node (one per physical core). See above for a more detailed discussion of the different sbatch options","title":"Example: job submission script for MPI parallel job"},{"location":"user-guide/scheduler/#example-job-submission-script-for-mpiopenmp-mixed-mode-parallel-job","text":"Mixed mode codes that use both MPI (or another distributed memory parallel model) and OpenMP should take care to ensure that the shared memory portion of the process/thread placement does not span more than one node. This means that the number of shared memory threads should be a factor of 128. In the example below, we are using 4 nodes for 6 hours. There are 32 MPI processes in total (8 MPI processes per node) and 16 OpenMP threads per MPI process. This results in all 128 physical cores per node being used. Note Note the use of the export OMP_PLACES=cores environment option and the --hint=nomultithread and --distribution=block:block options to srun to generate the correct pinning. #!/bin/bash # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=Example_MPI_Job #SBATCH --time=0:20:0 #SBATCH --nodes=4 #SBATCH --ntasks=32 #SBATCH --tasks-per-node=8 #SBATCH --cpus-per-task=16 # Replace [budget code] below with your project code (e.g. t01) #SBATCH --account=[budget code] # Set the number of threads to 16 and specify placement # There are 16 OpenMP threads per MPI process # We want one thread per physical core export OMP_NUM_THREADS=16 export OMP_PLACES=cores # Launch the parallel job # Using 32 MPI processes # 8 MPI processes per node # 16 OpenMP threads per MPI process # Additional srun options to pin one thread per physical core srun --hint=nomultithread --distribution=block:block ./my_mixed_executable.x arg1 arg2","title":"Example: job submission script for MPI+OpenMP (mixed mode) parallel job"},{"location":"user-guide/scheduler/#job-arrays","text":"The Slurm job scheduling system offers the job array concept, for running collections of almost-identical jobs. For example, running the same program several times with different arguments or input data. Each job in a job array is called a subjob . The subjobs of a job array can be submitted and queried as a unit, making it easier and cleaner to handle the full set, compared to individual jobs. All subjobs in a job array are started by running the same job script. The job script also contains information on the number of jobs to be started, and Slurm provides a subjob index which can be passed to the individual subjobs or used to select the input data per subjob.","title":"Job arrays"},{"location":"user-guide/scheduler/#job-script-for-a-job-array","text":"As an example, the following script runs 56 subjobs, with the subjob index as the only argument to the executable. Each subjob requests a single node and uses all 128 cores on the node by placing 1 MPI process per core and specifies 4 hours maximum runtime per subjob: #!/bin/bash # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=Example_Array_Job #SBATCH --time=0:20:0 #SBATCH --nodes=4 #SBATCH --tasks-per-node=128 #SBATCH --cpus-per-task=1 #SBATCH --array=0-55 # Replace [budget code] below with your budget code (e.g. t01) #SBATCH --account=[budget code] # Set the number of threads to 1 # This prevents any threaded system libraries from automatically # using threading. export OMP_NUM_THREADS=1 srun --cpu-bind=cores /path/to/exe $Slurm_ARRAY_TASK_ID","title":"Job script for a job array"},{"location":"user-guide/scheduler/#submitting-a-job-array","text":"Job arrays are submitted using sbatch in the same way as for standard jobs: sbatch job_script.pbs","title":"Submitting a job array"},{"location":"user-guide/scheduler/#job-chaining","text":"Job dependencies can be used to construct complex pipelines or chain together long simulations requiring multiple steps. Note The --parsable option to sbatch can simplify working with job dependencies. It returns the job ID in a format that can be used as the input to other commands. For example: jobid=$(sbatch --parsable first_job.sh) sbatch --dependency=afterok:$jobid second_job.sh or for a longer chain: jobid1=$(sbatch --parsable first_job.sh) jobid2=$(sbatch --parsable --dependency=afterok:$jobid1 second_job.sh) jobid3=$(sbatch --parsable --dependency=afterok:$jobid1 third_job.sh) sbatch --dependency=afterok:$jobid2,afterok:$jobid3 last_job.sh","title":"Job chaining"},{"location":"user-guide/scheduler/#interactive-jobs-salloc","text":"When you are developing or debugging code you often want to run many short jobs with a small amount of editing the code between runs. This can be achieved by using the login nodes to run MPI but you may want to test on the compute nodes (e.g. you may want to test running on multiple nodes across the high performance interconnect). One of the best ways to achieve this on ARCHER2 is to use interactive jobs. An interactive job allows you to issue srun commands directly from the command line without using a job submission script, and to see the output from your program directly in the terminal. You use the salloc command to reserve compute nodes for interactive jobs. To submit a request for an interactive job reserving 8 nodes (1024 physical cores) for 1 hour you would issue the following qsub command from the command line: salloc --nodes=8 --tasks-per-node=128 --cpus-per-task=1 --time=1:0:0 --account=[budget code] When you submit this job your terminal will display something like: salloc: Granted job allocation 24236 salloc: Waiting for resource configuration salloc: Nodes nid000002 are ready for job It may take some time for your interactive job to start. Once it runs you will enter a standard interactive terminal session. Whilst the interactive session lasts you will be able to run parallel jobs on the compute nodes by issuing the srun --cpu-bind=cores command directly at your command prompt using the same syntax as you would inside a job script. The maximum number of nodes you can use is limited by resources requested in the salloc command. If you know you will be doing a lot of intensive debugging you may find it useful to request an interactive session lasting the expected length of your working session, say a full day. Your session will end when you hit the requested walltime. If you wish to finish before this you should use the exit command - this will return you to your prompt before you issued the salloc command.","title":"Interactive Jobs: salloc"},{"location":"user-guide/scheduler/#reservations","text":"The mechanism for submitting reservations on ARCHER2 has yet to be specified.","title":"Reservations"},{"location":"user-guide/scheduler/#best-practices-for-job-submission","text":"This guidance is adapted from the advice provided by NERSC","title":"Best practices for job submission"},{"location":"user-guide/scheduler/#do-not-run-production-jobs-in-home","text":"As a general best practice, users should run production runs from the /work file systems rather than the /home file systems. The /home file system is designed for permanent and relatively small storage. It is not tuned to perform well for parallel jobs and large amounts of I/O. Home is perfect for storing files such as source codes and shell scripts. Please note that while building software in /home is generally OK, it is best to install dynamic libraries and binaries that are used on compute nodes on the /work file systems for best performance. The /work file systems are designed for large, temporary storage, particularly for I/O from parallel jobs running on the compute nodes and large scale data analysis (although the solid state storage may provide better performance in particular scenarios). Running jobs on the /work file systems also helps to improve the responsiveness of the /home file systems for all users.","title":"Do not run production jobs in /home"},{"location":"user-guide/scheduler/#time-limits","text":"Due to backfill scheduling, short and variable-length jobs generally start quickly resulting in much better job throughput. You can specify a minimum time for your job with the --time-min option to SBATCH: #SBATCH --time-min=<lower_bound> #SBATCH --time=<upper_bound> Within your job script, you can get the time remaining in the job with squeue -h -j ${Slurm_JOBID} -o %L to allow you to deal with potentially varying runtimes when using this option.","title":"Time Limits"},{"location":"user-guide/scheduler/#long-running-jobs","text":"Simulations which must run for a long period of time achieve the best throughput when composed of many small jobs using a checkpoint and restart method chained together (see above for how to chain jobs together). However, this method does occur a startup and shutdown overhead for each job as the state is saved and loaded so you should experiment to find the best balance between runtime (long runtimes minimise the checkpoint/restart overheads) and throughput (short runtimes maximise throughput).","title":"Long Running Jobs"},{"location":"user-guide/scheduler/#io-performance","text":"","title":"I/O performance"},{"location":"user-guide/scheduler/#large-jobs","text":"Large jobs may take longer to start up. The sbcast command is recommended for large jobs requesting over 1500 MPI tasks. By default, Slurm reads the executable on the allocated compute nodes from the location where it is installed; this may take long time when the file system (where the executable resides) is slow or busy. The sbcast command, the executable can be copied to the /tmp directory on each of the compute nodes. Since /tmp is part of the memory on the compute nodes, it can speed up the job startup time. sbcast --compress=lz4 /path/to/exe /tmp/exe srun /tmp/exe","title":"Large Jobs"},{"location":"user-guide/scheduler/#network-locality","text":"For jobs which are sensitive to interconnect (MPI) performance and utilize less than or equal to 256 nodes it is possible to request that all nodes are in a single Slingshot dragonfly group. Slurm has a concept of \"switches\" which on ARCHER2 are configured to map to Slingshot groups (there are 256 nodes per group). Since this places an additional constraint on the scheduler a maximum time to wait for the requested topology can be specified. For example: sbatch --switches=1@60 job.sh``","title":"Network Locality"},{"location":"user-guide/scheduler/#process-placement","text":"Several mechanisms exist to control process placement on ARCHER2. Application performance can depend strongly on placement depending on the communication pattern and other computational characteristics.","title":"Process Placement"},{"location":"user-guide/scheduler/#default","text":"The default is to place MPI tasks sequentially on nodes until the maximum number of tasks is reached: salloc --nodes=8 --tasks-per-node=2 --cpus-per-task=1 --time=0:10:0 --account=t01 salloc: Granted job allocation 24236 salloc: Waiting for resource configuration salloc: Nodes cn13 are ready for job module load xthi export OMP_NUM_THREADS=1 srun --cpu-bind=cores xthi Hello from rank 0, thread 0, on nid000001. (core affinity = 0,128) Hello from rank 1, thread 0, on nid000001. (core affinity = 16,144) Hello from rank 2, thread 0, on nid000002. (core affinity = 0,128) Hello from rank 3, thread 0, on nid000002. (core affinity = 16,144) Hello from rank 4, thread 0, on nid000003. (core affinity = 0,128) Hello from rank 5, thread 0, on nid000003. (core affinity = 16,144) Hello from rank 6, thread 0, on nid000004. (core affinity = 0,128) Hello from rank 7, thread 0, on nid000004. (core affinity = 16,144) Hello from rank 8, thread 0, on nid000005. (core affinity = 0,128) Hello from rank 9, thread 0, on nid000005. (core affinity = 16,144) Hello from rank 10, thread 0, on nid000006. (core affinity = 0,128) Hello from rank 11, thread 0, on nid000006. (core affinity = 16,144) Hello from rank 12, thread 0, on nid000007. (core affinity = 0,128) Hello from rank 13, thread 0, on nid000007. (core affinity = 16,144) Hello from rank 14, thread 0, on nid000008. (core affinity = 0,128) Hello from rank 15, thread 0, on nid000008. (core affinity = 16,144)","title":"Default"},{"location":"user-guide/scheduler/#mpich_rank_reorder_method","text":"The MPICH_RANK_REORDER_METHOD environment variable is used to specify other types of MPI task placement. For example, setting it to 0 results in a round-robin placement: salloc --nodes=8 --tasks-per-node=2 --cpus-per-task=1 --time=0:10:0 --account=t01 salloc: Granted job allocation 24236 salloc: Waiting for resource configuration salloc: Nodes cn13 are ready for job module load xthi export OMP_NUM_THREADS=1 export MPICH_RANK_REORDER_METHOD=0 srun --cpu-bind=cores xthi Hello from rank 0, thread 0, on nid000001. (core affinity = 0,128) Hello from rank 1, thread 0, on nid000002. (core affinity = 0,128) Hello from rank 2, thread 0, on nid000003. (core affinity = 0,128) Hello from rank 3, thread 0, on nid000004. (core affinity = 0,128) Hello from rank 4, thread 0, on nid000005. (core affinity = 0,128) Hello from rank 5, thread 0, on nid000006. (core affinity = 0,128) Hello from rank 6, thread 0, on nid000007. (core affinity = 0,128) Hello from rank 7, thread 0, on nid000008. (core affinity = 0,128) Hello from rank 8, thread 0, on nid000001. (core affinity = 16,144) Hello from rank 9, thread 0, on nid000002. (core affinity = 16,144) Hello from rank 10, thread 0, on nid000003. (core affinity = 16,144) Hello from rank 11, thread 0, on nid000004. (core affinity = 16,144) Hello from rank 12, thread 0, on nid000005. (core affinity = 16,144) Hello from rank 13, thread 0, on nid000006. (core affinity = 16,144) Hello from rank 14, thread 0, on nid000007. (core affinity = 16,144) Hello from rank 15, thread 0, on nid000008. (core affinity = 16,144) There are other modes available with the MPICH_RANK_REORDER_METHOD environment variable, including one which lets the user provide a file called MPICH_RANK_ORDER which contains a list of each task's placement on each node. These options are described in detail in the intro_mpi man page. grid_order For MPI applications which perform a large amount of nearest-neighbor communication, e.g., stencil-based applications on structured grids, Cray provides a tool in the perftools-base module called grid_order which can generate a MPICH_RANK_ORDER file automatically by taking as parameters the dimensions of the grid, core count, etc. For example, to place MPI tasks in row-major order on a Cartesian grid of size $(4, 4, 4)$, using 32 tasks per node: module load perftools-base grid_order -R -c 32 -g 4,4,4 # grid_order -R -Z -c 32 -g 4,4,4 # Region 3: 0,0,1 (0..63) 0,1,2,3,16,17,18,19,32,33,34,35,48,49,50,51,4,5,6,7,20,21,22,23,36,37,38,39,52,53,54,55 8,9,10,11,24,25,26,27,40,41,42,43,56,57,58,59,12,13,14,15,28,29,30,31,44,45,46,47,60,61,62,63 One can then save this output to a file called MPICH_RANK_ORDER and then set MPICH_RANK_REORDER_METHOD=3 before running the job, which tells Cray MPI to read the MPICH_RANK_ORDER file to set the MPI task placement. For more information, please see the man page man grid_order (available when the perftools-base module is loaded).","title":"MPICH_RANK_REORDER_METHOD"},{"location":"user-guide/scheduler/#huge-pages","text":"Huge pages are virtual memory pages which are bigger than the default page size of 4K bytes. Huge pages can improve memory performance for common access patterns on large data sets since it helps to reduce the number of virtual to physical address translations when compared to using the default 4KB. To use huge pages for an application (with the 2 MB huge pages as an example): module load craype-hugepages2M cc -o mycode.exe mycode.c And also load the same huge pages module at runtime. Warning Due to the huge pages memory fragmentation issue, applications may get Cannot allocate memory warnings or errors when there are not enough hugepages on the compute node, such as: : libhugetlbfs [nid0000xx:xxxxx]: WARNING: New heap segment map at 0x10000000 failed: Cannot allocate memory`` By default, The verbosity level of libhugetlbfs HUGETLB_VERBOSE is set to 0 on ARCHER2 to surpress debugging messages. Users can adjust this value to obtain more information on huge pages use.","title":"Huge pages"},{"location":"user-guide/scheduler/#when-to-use-huge-pages","text":"For MPI applications, map the static data and/or heap onto huge pages. For an application which uses shared memory, which needs to be concurrently registered with the high speed network drivers for remote communication. For SHMEM applications, map the static data and/or private heap onto huge pages. For applications written in Unified Parallel C, Coarray Fortran, and other languages based on the PGAS programming model, map the static data and/or private heap onto huge pages. For an application doing heavy I/O. To improve memory performance for common access patterns on large data sets.","title":"When to Use Huge Pages"},{"location":"user-guide/scheduler/#when-to-avoid-huge-pages","text":"Applications sometimes consist of many steering programs in addition to the core application. Applying huge page behavior to all processes would not provide any benefit and would consume huge pages that would otherwise benefit the core application. The runtime environment variable HUGETLB_RESTRICT_EXE can be used to specify the susbset of the programs to use hugepages. For certain applications if using hugepages either causes issues or slows down performance. One such example is that when an application forks more subprocesses (such as pthreads) and these threads allocate memory, the newly allocated memory are the default 4 KB pages.","title":"When to Avoid Huge Pages"},{"location":"user-guide/sw-environment/","text":"Software environment Warning The ARCHER2 Service is not yet available. This documentation is in development. The software environment on ARCHER2 is primarily controlled through the module command. By loading and switching software modules you control which software and versions are available to you. Note A module is a self-contained description of a software package -- it contains the settings required to run a software package and, usually, encodes required dependencies on other software packages. By default, all users on ARCHER2 start with the default software environment loaded. Software modules on ARCHER2 are provided by both Cray (usually known as the Cray Development Environment, CDE ) and by EPCC, who provide the Service Provision, and Computational Science and Engineering services. In this section, we provide: A brief overview of the module command A brief description of how the module command manipulates your environment Using the module command We only cover basic usage of the module command here. For full documentation please see the Linux manual page on modules The module command takes a subcommand to indicate what operation you wish to perform. Common subcommands are: module list [name] - List modules currently loaded in your environment, optionally filtered by [name] module avail [name] - List modules available, optionally filtered by [name] module load name - Load the module called name into your environment module remove name - Remove the module called name from your environment module swap old new - Swap module new for module old in your environment module help name - Show help information on module name module show name - List what module name actually does to your environment These are described in more detail below. Information on the available modules The module list command will give the names of the modules and their versions you have presently loaded in your environment: auser@login01-nmn:~> module list Currently Loaded Modulefiles: 1) cce/10.0.0(default) 2) cray-libsci/20.03.1.4(default) 3) cray-mpich/8.0.10(default) 4) PrgEnv-cray/7.0.0(default) 5) craype/2.6.4(default) 6) craype-x86-rome 7) libfabric/1.10.0.0.249(default) 8) craype-network-slingshot10 9) cray-dsmml/0.1.0(default) 10) perftools-base/20.05.0(default) 11) xpmem/2.2.35-7.0.1.0_3.9__gfa8d091.shasta(default) Finding out which software modules are available on the system is performed using the module avail command. To list all software modules available, use: auser@login01-nmn:~> module avail ----------------------- /opt/cray/pe/perftools/20.05.0/modulefiles ------------------------ perftools perftools-lite-events perftools-lite-hbm perftools-nwpc perftools-lite perftools-lite-gpu perftools-lite-loops perftools-preload -------------------------- /opt/cray/pe/craype/2.6.4/modulefiles -------------------------- craype-hugepages1G craype-hugepages8M craype-hugepages128M craype-network-slingshot10 craype-hugepages2G craype-hugepages16M craype-hugepages256M craype-x86-rome craype-hugepages2M craype-hugepages32M craype-hugepages512M craype-hugepages4M craype-hugepages64M craype-network-none ----------------------------- /usr/local/Modules/modulefiles ------------------------------ dot module-git module-info modules null use.own -------------------------------- /opt/cray/pe/modulefiles --------------------------------- atp/3.5.4(default) cray-openshmemx/10.1.0(default) cce/10.0.0(default) cray-parallel-netcdf/1.11.1.1(default) cray-ccdb/4.5.4(default) cray-pmi-lib/6.0.5(default) cray-cti/2.5.6(default) cray-pmi/6.0.5(default) cray-dsmml/0.1.0(default) cray-stat/4.4.5(default) cray-fftw/3.3.8.4(default) craype-dl-plugin-py3/20.05.1 cray-fftw/3.3.8.5 craype/2.6.4(default) cray-ga/5.7.0.3 craypkg-gen/1.3.9(default) cray-hdf5-parallel/1.10.5.2(default) gdb4hpc/4.5.6(default) cray-hdf5/1.10.5.2(default) iobuf/2.0.9(default) cray-libsci/20.03.1.4(default) papi/5.7.0.3(default) cray-mpich-abi/8.0.10 perftools-base/20.05.0(default) cray-mpich/8.0.10(default) PrgEnv-cray/7.0.0(default) cray-netcdf-hdf5parallel/4.6.3.2(default) PrgEnv-gnu/7.0.0(default) cray-netcdf/4.6.3.2(default) valgrind4hpc/2.5.5(default) ---------------------------------- /opt/cray/modulefiles ---------------------------------- capsules/0.8.3(default) chapel/1.20.1(default) cray-lustre-client/2.12.0.5_cray_166_gf6711cf-7.0.1.0_2.24__gf6711cfb3.shasta(default) cray-shasta-mlnx-firmware/1.0.5(default) dvs/2.12_2.2.259-7.0.1.0_6.1__g6ee74127(default) libfabric/1.10.0.0.249(default) spark/3.0.0(default) xpmem/2.2.35-7.0.1.0_3.9__gfa8d091.shasta(default) ------------------------------------ /opt/modulefiles ------------------------------------- cray-python/3.8.2.0(default) cray-R/3.6.3(default) gcc/8.1.0 gcc/9.3.0(default) This will list all the names and versions of the modules available on the service. Not all of them may work in your account though due to, for example, licencing restrictions. You will notice that for many modules we have more than one version, each of which is identified by a version number. One of these versions is the default. As the service develops the default version will change and old versions of software may be deleted. You can list all the modules of a particular type by providing an argument to the module avail command. For example, to list all available versions of the FFTW library, use: auser@login01-nmn:~> module avail cray-fftw --------------------------- /opt/cray/pe/modulefiles --------------------------- cray-fftw/3.3.8.4(default) cray-fftw/3.3.8.5 If you want more info on any of the modules, you can use the module help command: auser@login01-nmn:~> module help cray-fftw ------------------------------------------------------------------- Module Specific Help for /opt/cray/pe/modulefiles/cray-fftw/3.3.8.4: =================================================================== FFTW 3.3.8.4 ============ Release Date: ------------- November 2019 Purpose: -------- This Cray FFTW 3.3.8.4 release is supported on Cray Systems. FFTW is supported on the host CPU but not on the accelerator of Cray systems. The Cray FFTW 3.3.8.4 release provides the following: - Support for AMD Rome CPUs. See the Product and OS Dependencies section for details. [...] The module show command reveals what operations the module actually performs to change your environment when it is loaded. We provide a brief overview of what the significance of these different settings mean below. For example, for the default FFTW module: auser@login01-nmn:~> module show cray-fftw ------------------------------------------------------------------- /opt/cray/pe/modulefiles/cray-fftw/3.3.8.4: conflict cray-fftw conflict fftw setenv FFTW_VERSION 3.3.8.4 setenv CRAY_FFTW_VERSION 3.3.8.4 setenv CRAY_FFTW_PREFIX /opt/cray/pe/fftw/3.3.8.4/x86_rome setenv FFTW_ROOT /opt/cray/pe/fftw/3.3.8.4/x86_rome setenv FFTW_DIR /opt/cray/pe/fftw/3.3.8.4/x86_rome/lib setenv FFTW_INC /opt/cray/pe/fftw/3.3.8.4/x86_rome/include prepend-path PATH /opt/cray/pe/fftw/3.3.8.4/x86_rome/bin prepend-path MANPATH /opt/cray/pe/fftw/3.3.8.4/share/man prepend-path CRAY_LD_LIBRARY_PATH /opt/cray/pe/fftw/3.3.8.4/x86_rome/lib setenv PE_FFTW_REQUIRED_PRODUCTS PE_MPICH prepend-path PE_PKGCONFIG_PRODUCTS PE_FFTW setenv PE_FFTW_TARGET_broadwell broadwell setenv PE_FFTW_TARGET_haswell haswell setenv PE_FFTW_TARGET_ivybridge ivybridge setenv PE_FFTW_TARGET_mic_knl mic_knl setenv PE_FFTW_TARGET_sandybridge sandybridge setenv PE_FFTW_TARGET_share share setenv PE_FFTW_TARGET_x86_64 x86_64 [...] Loading, removing and swapping modules To load a module to use the module load command. For example, to load the default version of FFTW into your environment, use: module load cray-fftw Once you have done this, your environment will be setup to use the FFTW library. This version of the command will load the default version of FFTW. If you need a specific version of the software, you can add more information: module load cray-fftw/3.3.8.5 will load FFTW version 3.3.8.5 into your environment, regardless of the default. If you want to remove software from your environment, module remove will remove a loaded module: module remove cray-fftw will unload what ever version of cray-fftw (even if it is not the default) you might have loaded. There are many situations in which you might want to change the presently loaded version to a different one, such as trying the latest version which is not yet the default or using a legacy version to keep compatibility with old data. This can be achieved most easily by using \"module swap oldmodule newmodule\". Suppose you have loaded version 3.3.8.4 of cray-fftw , the following command will change to version 3.3.8.5: module swap cray-fftw cray-fftw/3.3.8.5 You did not need to specify the version of the loaded module in your current environment as this can be inferred as it will be the only one you have loaded. Note The module swap command is most often used on ARCHER2 to switch between different compiler environments, e.g. Cray compilers to GNU compilers. The software development environment is described in more detail in the dev-environment chapter. Capturing your environment for reuse Sometimes it is useful to save the module environment that you are using to compile a piece of code or execute a piece of software. You can save the list of loaded modules by executing: module save [environment_name] Note If you do not specify the environment name, it is called default . You can find the list of saved module enviroments by executing: module savelist You can load a saved module environment by executing: module restore <environment_name> To list the saved environment modules, you can execute: module saveshow To delete a module environment, you can execute: module saverm <environment_name> Shell environment overview When you log in to ARCHER2, you are using the bash shell by default. As any other software, the bash shell has loaded a set of environment variables that can be listed by executing printenv or export . The environment variables listed before are useful to define the behaviour of the software you run. For instance, OMP_NUM_THREADS define the number of threads. Another example is the environment variable CRAYPE_LINK_TYPE , which defines the linking type (static or dynamic). To define an environment variable, you need to execute: export OMP_NUM_THREADS=4 Please note there are no blanks between the variable name, the assignation symbol, and the value. If the value is a string, enclose the string in double quotation marks. You can show the value of a specific environment variable if you print it: echo $OMP_NUM_THREADS Do not forget the dollar symbol. To remove an environment variable, just execute: unset OMP_NUM_THREADS","title":"Sw environment"},{"location":"user-guide/sw-environment/#software-environment","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development. The software environment on ARCHER2 is primarily controlled through the module command. By loading and switching software modules you control which software and versions are available to you. Note A module is a self-contained description of a software package -- it contains the settings required to run a software package and, usually, encodes required dependencies on other software packages. By default, all users on ARCHER2 start with the default software environment loaded. Software modules on ARCHER2 are provided by both Cray (usually known as the Cray Development Environment, CDE ) and by EPCC, who provide the Service Provision, and Computational Science and Engineering services. In this section, we provide: A brief overview of the module command A brief description of how the module command manipulates your environment","title":"Software environment"},{"location":"user-guide/sw-environment/#using-the-module-command","text":"We only cover basic usage of the module command here. For full documentation please see the Linux manual page on modules The module command takes a subcommand to indicate what operation you wish to perform. Common subcommands are: module list [name] - List modules currently loaded in your environment, optionally filtered by [name] module avail [name] - List modules available, optionally filtered by [name] module load name - Load the module called name into your environment module remove name - Remove the module called name from your environment module swap old new - Swap module new for module old in your environment module help name - Show help information on module name module show name - List what module name actually does to your environment These are described in more detail below.","title":"Using the module command"},{"location":"user-guide/sw-environment/#information-on-the-available-modules","text":"The module list command will give the names of the modules and their versions you have presently loaded in your environment: auser@login01-nmn:~> module list Currently Loaded Modulefiles: 1) cce/10.0.0(default) 2) cray-libsci/20.03.1.4(default) 3) cray-mpich/8.0.10(default) 4) PrgEnv-cray/7.0.0(default) 5) craype/2.6.4(default) 6) craype-x86-rome 7) libfabric/1.10.0.0.249(default) 8) craype-network-slingshot10 9) cray-dsmml/0.1.0(default) 10) perftools-base/20.05.0(default) 11) xpmem/2.2.35-7.0.1.0_3.9__gfa8d091.shasta(default) Finding out which software modules are available on the system is performed using the module avail command. To list all software modules available, use: auser@login01-nmn:~> module avail ----------------------- /opt/cray/pe/perftools/20.05.0/modulefiles ------------------------ perftools perftools-lite-events perftools-lite-hbm perftools-nwpc perftools-lite perftools-lite-gpu perftools-lite-loops perftools-preload -------------------------- /opt/cray/pe/craype/2.6.4/modulefiles -------------------------- craype-hugepages1G craype-hugepages8M craype-hugepages128M craype-network-slingshot10 craype-hugepages2G craype-hugepages16M craype-hugepages256M craype-x86-rome craype-hugepages2M craype-hugepages32M craype-hugepages512M craype-hugepages4M craype-hugepages64M craype-network-none ----------------------------- /usr/local/Modules/modulefiles ------------------------------ dot module-git module-info modules null use.own -------------------------------- /opt/cray/pe/modulefiles --------------------------------- atp/3.5.4(default) cray-openshmemx/10.1.0(default) cce/10.0.0(default) cray-parallel-netcdf/1.11.1.1(default) cray-ccdb/4.5.4(default) cray-pmi-lib/6.0.5(default) cray-cti/2.5.6(default) cray-pmi/6.0.5(default) cray-dsmml/0.1.0(default) cray-stat/4.4.5(default) cray-fftw/3.3.8.4(default) craype-dl-plugin-py3/20.05.1 cray-fftw/3.3.8.5 craype/2.6.4(default) cray-ga/5.7.0.3 craypkg-gen/1.3.9(default) cray-hdf5-parallel/1.10.5.2(default) gdb4hpc/4.5.6(default) cray-hdf5/1.10.5.2(default) iobuf/2.0.9(default) cray-libsci/20.03.1.4(default) papi/5.7.0.3(default) cray-mpich-abi/8.0.10 perftools-base/20.05.0(default) cray-mpich/8.0.10(default) PrgEnv-cray/7.0.0(default) cray-netcdf-hdf5parallel/4.6.3.2(default) PrgEnv-gnu/7.0.0(default) cray-netcdf/4.6.3.2(default) valgrind4hpc/2.5.5(default) ---------------------------------- /opt/cray/modulefiles ---------------------------------- capsules/0.8.3(default) chapel/1.20.1(default) cray-lustre-client/2.12.0.5_cray_166_gf6711cf-7.0.1.0_2.24__gf6711cfb3.shasta(default) cray-shasta-mlnx-firmware/1.0.5(default) dvs/2.12_2.2.259-7.0.1.0_6.1__g6ee74127(default) libfabric/1.10.0.0.249(default) spark/3.0.0(default) xpmem/2.2.35-7.0.1.0_3.9__gfa8d091.shasta(default) ------------------------------------ /opt/modulefiles ------------------------------------- cray-python/3.8.2.0(default) cray-R/3.6.3(default) gcc/8.1.0 gcc/9.3.0(default) This will list all the names and versions of the modules available on the service. Not all of them may work in your account though due to, for example, licencing restrictions. You will notice that for many modules we have more than one version, each of which is identified by a version number. One of these versions is the default. As the service develops the default version will change and old versions of software may be deleted. You can list all the modules of a particular type by providing an argument to the module avail command. For example, to list all available versions of the FFTW library, use: auser@login01-nmn:~> module avail cray-fftw --------------------------- /opt/cray/pe/modulefiles --------------------------- cray-fftw/3.3.8.4(default) cray-fftw/3.3.8.5 If you want more info on any of the modules, you can use the module help command: auser@login01-nmn:~> module help cray-fftw ------------------------------------------------------------------- Module Specific Help for /opt/cray/pe/modulefiles/cray-fftw/3.3.8.4: =================================================================== FFTW 3.3.8.4 ============ Release Date: ------------- November 2019 Purpose: -------- This Cray FFTW 3.3.8.4 release is supported on Cray Systems. FFTW is supported on the host CPU but not on the accelerator of Cray systems. The Cray FFTW 3.3.8.4 release provides the following: - Support for AMD Rome CPUs. See the Product and OS Dependencies section for details. [...] The module show command reveals what operations the module actually performs to change your environment when it is loaded. We provide a brief overview of what the significance of these different settings mean below. For example, for the default FFTW module: auser@login01-nmn:~> module show cray-fftw ------------------------------------------------------------------- /opt/cray/pe/modulefiles/cray-fftw/3.3.8.4: conflict cray-fftw conflict fftw setenv FFTW_VERSION 3.3.8.4 setenv CRAY_FFTW_VERSION 3.3.8.4 setenv CRAY_FFTW_PREFIX /opt/cray/pe/fftw/3.3.8.4/x86_rome setenv FFTW_ROOT /opt/cray/pe/fftw/3.3.8.4/x86_rome setenv FFTW_DIR /opt/cray/pe/fftw/3.3.8.4/x86_rome/lib setenv FFTW_INC /opt/cray/pe/fftw/3.3.8.4/x86_rome/include prepend-path PATH /opt/cray/pe/fftw/3.3.8.4/x86_rome/bin prepend-path MANPATH /opt/cray/pe/fftw/3.3.8.4/share/man prepend-path CRAY_LD_LIBRARY_PATH /opt/cray/pe/fftw/3.3.8.4/x86_rome/lib setenv PE_FFTW_REQUIRED_PRODUCTS PE_MPICH prepend-path PE_PKGCONFIG_PRODUCTS PE_FFTW setenv PE_FFTW_TARGET_broadwell broadwell setenv PE_FFTW_TARGET_haswell haswell setenv PE_FFTW_TARGET_ivybridge ivybridge setenv PE_FFTW_TARGET_mic_knl mic_knl setenv PE_FFTW_TARGET_sandybridge sandybridge setenv PE_FFTW_TARGET_share share setenv PE_FFTW_TARGET_x86_64 x86_64 [...]","title":"Information on the available modules"},{"location":"user-guide/sw-environment/#loading-removing-and-swapping-modules","text":"To load a module to use the module load command. For example, to load the default version of FFTW into your environment, use: module load cray-fftw Once you have done this, your environment will be setup to use the FFTW library. This version of the command will load the default version of FFTW. If you need a specific version of the software, you can add more information: module load cray-fftw/3.3.8.5 will load FFTW version 3.3.8.5 into your environment, regardless of the default. If you want to remove software from your environment, module remove will remove a loaded module: module remove cray-fftw will unload what ever version of cray-fftw (even if it is not the default) you might have loaded. There are many situations in which you might want to change the presently loaded version to a different one, such as trying the latest version which is not yet the default or using a legacy version to keep compatibility with old data. This can be achieved most easily by using \"module swap oldmodule newmodule\". Suppose you have loaded version 3.3.8.4 of cray-fftw , the following command will change to version 3.3.8.5: module swap cray-fftw cray-fftw/3.3.8.5 You did not need to specify the version of the loaded module in your current environment as this can be inferred as it will be the only one you have loaded. Note The module swap command is most often used on ARCHER2 to switch between different compiler environments, e.g. Cray compilers to GNU compilers. The software development environment is described in more detail in the dev-environment chapter.","title":"Loading, removing and swapping modules"},{"location":"user-guide/sw-environment/#capturing-your-environment-for-reuse","text":"Sometimes it is useful to save the module environment that you are using to compile a piece of code or execute a piece of software. You can save the list of loaded modules by executing: module save [environment_name] Note If you do not specify the environment name, it is called default . You can find the list of saved module enviroments by executing: module savelist You can load a saved module environment by executing: module restore <environment_name> To list the saved environment modules, you can execute: module saveshow To delete a module environment, you can execute: module saverm <environment_name>","title":"Capturing your environment for reuse"},{"location":"user-guide/sw-environment/#shell-environment-overview","text":"When you log in to ARCHER2, you are using the bash shell by default. As any other software, the bash shell has loaded a set of environment variables that can be listed by executing printenv or export . The environment variables listed before are useful to define the behaviour of the software you run. For instance, OMP_NUM_THREADS define the number of threads. Another example is the environment variable CRAYPE_LINK_TYPE , which defines the linking type (static or dynamic). To define an environment variable, you need to execute: export OMP_NUM_THREADS=4 Please note there are no blanks between the variable name, the assignation symbol, and the value. If the value is a string, enclose the string in double quotation marks. You can show the value of a specific environment variable if you print it: echo $OMP_NUM_THREADS Do not forget the dollar symbol. To remove an environment variable, just execute: unset OMP_NUM_THREADS","title":"Shell environment overview"},{"location":"user-guide/tuning/","text":"Performance tuning Warning The ARCHER2 Service is not yet available. This documentation is in development. MPI The vast majority of parallel scientific software uses the MPI library as the main way to implement parallelism; it is used so universally that the Cray compiler wrappers on ARCHER2 link to the Cray MPI library by default. Unlike other clusters you may have used, there is no choice of MPI library on ARCHER2: regardless of what compiler you are using, your program will use Cray MPI. This is because the Slingshot network on ARCHER2 is Cray-specific and significant effort has been put in by Cray software engineers to optimise the MPI performance on Cray Shasta systems. Here we list a number of suggestions for improving the performance of your MPI programs on ARCHER2. Although MPI programs are capable of scaling very well due to the bespoke communications hardware and software, the details of how a program calls MPI can have significant effects on achieved performance. Note Many of these tips are actually quite generic and should be beneficial to any MPI program; however, they all become much more important when running on very large numbers of processes on a machine the size of ARCHER2. Synchronous vs asynchronous communications MPI_Send A standard way to send data in MPI is using MPI_Send (aptly called standard send ). Somewhat confusingly, MPI is allowed to choose how to implement this in two different ways: Synchronously The sending process waits until a matching receive has been posted, i.e. it operates like MPI_Ssend . This clearly has the risk of deadlock if no receive is ever issued. Asynchronously MPI makes a copy of the message into an internal buffer and returns straight away without waiting for a matching receive; the message may actually be delivered later on. This is like the behaviour of the the buffered send routine MPI_Bsend . The rationale is that MPI, rather than the user, should decide how best to send a message. In practice, what typically happens is that MPI tries to use an asynchronous approach via the eager protocol -- the message is copied directly to a preallocated buffer on the receiver and the routine returns immediately afterward. Clearly there is a limit on how much space can be reserved for this, so: small messages will be sent asynchronously; large messages will be sent synchronously. The threshold is often termed the eager limit which is fixed for the entire run of your program. It will have some default setting which varies from system to system, but might be around 8K bytes. Implications An MPI program will typically run faster if MPI_Send is implemented asynchronously using the eager protocol since synchronisation between sender and receive is much reduced. However, you should never assume that MPI_Send buffers your message, so if you have concerns about deadlock you will need to use the non-blocking variant MPI_Isend to guarantee that the send routine returns control to you immediately even if there is no matching receive. It is not enough to say *deadlock is an issue in principle, but it runs OK on my laptop so there is no problem in practice*. The eager limit is system-dependent so the fact that a message happens to be buffered on your laptop is no guarantee it will be buffered on ARCHER2. To check that you have a correct code, replace all instances of MPI_Send / MPI_Isend with MPI_Ssend / MPI_Issend . A correct MPI program should still run correctly when all references to standard send are replaced by synchronous send (since MPI is allowed to implement standard send as synchronous send). Tuning performance With most MPI libraries you should be able to alter the default value of the eager limit at runtime, perhaps via an environment variable or a command-line argument to mpirun . On ARCHER, the magic incantation is: export MPICH_GNI_MAX_EAGER_MSG_SIZE=16382 which would mean that messages below 16K bytes are sent asynchronously (there will be a similar, but different, incantation on ARCHER2). The advice for tuning the performance of MPI_Send is find out what the distribution of message sizes for MPI_Send is (a profiling tool may be useful here); this applies to MPI_Isend as well: even in the non-blocking form, which can help to weaken synchronisation between sender and receiver, the amount of hand-shaking required is much reduced if the eager protocol is used; find out from the system documentation how to alter the value of the eager limit (there is no standardised way to set it); set the eager limit to a value larger than your typical message size -- you may need to add a small amount, say a few hundred bytes, to allow for any additional header information that is added to each message; measure the performance before and after to check that it has improved. Note It cannot be stressed strongly enough that although the performance may be affected by the value of the eager limit, the functionality of your program should be unaffected. If changing the eager limit affects the correctness of your program (e.g. whether or not it deadlocks) then you have an incorrect MPI program . Collective operations Many of the collective operations that are commonly required by parallel scientific programs, i.e. operations that involve a group of processes, are already implemented in MPI. The canonical operation is perhaps adding up a double precision number across all MPI processes, which is best achieved by a reduction operation : MPI_Allreduce(&x, &xsum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD); This will be implemented using an efficient algorithm, for example based on a binary tree. Using such divide-and-conquer approaches typically results in an algorithm whose execution time on P processes scales as l o g 2 ( P ); compare this to a naive approach where every process sends its input to rank 0 where the time will scale as P . This might not be significant on your laptop, but even on as few as 1000 processes the tree-based algorithm will already be around 100 times faster. So, the basic advice is **always use a collective routine to implement your communications pattern** if at all possible. In real MPI applications, collective operations are often called on a small amount of data, for example a global reduction of a single variable. In these cases, the time taken will be dominated by message latency and the first port of call when looking at performance optimisation is to call them as infrequently as possible! If you are simply printing diagnostics to the screen in an iterative loop, consider doing this less frequently, e.g every ten iterations, or even not at all (although you should easily be able to turn diagnostics on again for future debugging). If you are computing some termination criterion, it may actually be faster overall to compute it and check for convergence infrequently, e.g. every ten iterations, even although this means that your program could run for up to 9 extra iterations. If possible, group data into a single buffer and call a single reduction with count > 1; two reductions with count = 1 will take almost exactly twice as long as a single reduction with count = 2. For example, if you only need to output a sequence of summed data at the end of the run, store the partial totals in an array and do a single reduction right at the end. Sometimes, the collective routines available may not appear to do exactly what you want. However, they can sometimes be used with a small amount of additional programming work: To operate on a subset of processes, create sub-communicators containing the relevant subset(s) and use these communicators instead of MPI_COMM_WORLD . Useful functions for communicator management include: MPI_Comm_split is the most general routine; MPI_Comm_split_type can be used to create a separate communicator for each shared-memory node with split type = MPI_COMM_TYPE_SHARED ; MPI_Cart_sub can divide a Cartesian communicator into regular slices. If the communication pattern is what you want, but the data on each process is not arranged in the required layout, consider using MPI derived data types for the input and/or output. This can be useful, for example, if you want to communicate non-contiguous data such as a subsection of a multidimensional array although care must be taken in defining these types to ensure they have the correct extents. Another example would be using MPI_Allreduce to add up an integer and a double-precision variable using a single call by putting them together into a C struct and defining a matching MPI datatype using MPI_Type_create_struct . Here you would also have to provide MPI with a custom reduction operation using MPI_Op_create . Many MPI programs call MPI_Barrier to explicitly synchronise all the processes. Although this can be useful for getting reliable performance timings, it is rare in practice to find a program where the call is actually needed for correctness. For example, you may see: // Ensure the input x is available on all processes MPI_Barrier(MPI_COMM_WORLD); // Perform a global reduction operation MPI_Allreduce(&x, &xsum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD); // Ensure the result xsum is available on all processes MPI_Barrier(MPI_COMM_WORLD); Neither of these barriers are needed as the reduction operation performs all the required synchronisation. If removing a barrier from your MPI code makes it run incorrectly, then this should ring alarm bells -- it is often a symptom of an underlying bug that is simply being masked by the barrier. For example, if you use non-blocking calls such as MPI_Irecv then it is the programmer's responsibility to ensure that these are completed at some later point, for example by calling MPI_Wait on the returned request object. A common bug is to forget to do this, in which case you might be reading the contents of the receive buffer before the incoming message has arrived (e.g. if the sender is running late). Calling a barrier may mask this bug as it will make all the processes wait for each other, perhaps allowing the late sender to catch up. However, this is not guaranteed so the real solution is to call the non-blocking communications correctly. One of the few times when a barrier may be required is if processes are communicating with each other via some other non-MPI method, e.g. via the file system. If you want processes to sequentially open, append to, then close the same file then barriers are a simple way to achieve this: for (i=0; i < size; i++) { if (rank == i) append_data_to_file(data, filename); MPI_Barrier(comm); } but this is really something of a special case. Global synchronisation may be required if you are using more advanced techniques such as hybrid MPI/OpenMP or single-sided MPI communication with put and get, but typically you should be using specialised routines such as MPI_Win_fence rather than MPI_Barrier . Note If you run a performance profiler on your code and it shows a lot of time being spent in a collective operation such as MPI_Allreduce , this is not necessarily a sign that the reduction operation itself is the bottleneck. This is often a symptom of load imbalance : even if a reduction operation is efficiently implemented, it may take a long time to complete if the MPI processes do not all call it at the same time. MPI_Allreduce synchronises across processes so will have to wait for all the processes to call it before it can complete. A single slow process will therefore adversely impact the performance of your entire parallel program.","title":"Tuning"},{"location":"user-guide/tuning/#performance-tuning","text":"Warning The ARCHER2 Service is not yet available. This documentation is in development.","title":"Performance tuning"},{"location":"user-guide/tuning/#mpi","text":"The vast majority of parallel scientific software uses the MPI library as the main way to implement parallelism; it is used so universally that the Cray compiler wrappers on ARCHER2 link to the Cray MPI library by default. Unlike other clusters you may have used, there is no choice of MPI library on ARCHER2: regardless of what compiler you are using, your program will use Cray MPI. This is because the Slingshot network on ARCHER2 is Cray-specific and significant effort has been put in by Cray software engineers to optimise the MPI performance on Cray Shasta systems. Here we list a number of suggestions for improving the performance of your MPI programs on ARCHER2. Although MPI programs are capable of scaling very well due to the bespoke communications hardware and software, the details of how a program calls MPI can have significant effects on achieved performance. Note Many of these tips are actually quite generic and should be beneficial to any MPI program; however, they all become much more important when running on very large numbers of processes on a machine the size of ARCHER2.","title":"MPI"},{"location":"user-guide/tuning/#synchronous-vs-asynchronous-communications","text":"","title":"Synchronous vs asynchronous communications"},{"location":"user-guide/tuning/#mpi_send","text":"A standard way to send data in MPI is using MPI_Send (aptly called standard send ). Somewhat confusingly, MPI is allowed to choose how to implement this in two different ways: Synchronously The sending process waits until a matching receive has been posted, i.e. it operates like MPI_Ssend . This clearly has the risk of deadlock if no receive is ever issued. Asynchronously MPI makes a copy of the message into an internal buffer and returns straight away without waiting for a matching receive; the message may actually be delivered later on. This is like the behaviour of the the buffered send routine MPI_Bsend . The rationale is that MPI, rather than the user, should decide how best to send a message. In practice, what typically happens is that MPI tries to use an asynchronous approach via the eager protocol -- the message is copied directly to a preallocated buffer on the receiver and the routine returns immediately afterward. Clearly there is a limit on how much space can be reserved for this, so: small messages will be sent asynchronously; large messages will be sent synchronously. The threshold is often termed the eager limit which is fixed for the entire run of your program. It will have some default setting which varies from system to system, but might be around 8K bytes.","title":"MPI_Send"},{"location":"user-guide/tuning/#implications","text":"An MPI program will typically run faster if MPI_Send is implemented asynchronously using the eager protocol since synchronisation between sender and receive is much reduced. However, you should never assume that MPI_Send buffers your message, so if you have concerns about deadlock you will need to use the non-blocking variant MPI_Isend to guarantee that the send routine returns control to you immediately even if there is no matching receive. It is not enough to say *deadlock is an issue in principle, but it runs OK on my laptop so there is no problem in practice*. The eager limit is system-dependent so the fact that a message happens to be buffered on your laptop is no guarantee it will be buffered on ARCHER2. To check that you have a correct code, replace all instances of MPI_Send / MPI_Isend with MPI_Ssend / MPI_Issend . A correct MPI program should still run correctly when all references to standard send are replaced by synchronous send (since MPI is allowed to implement standard send as synchronous send).","title":"Implications"},{"location":"user-guide/tuning/#tuning-performance","text":"With most MPI libraries you should be able to alter the default value of the eager limit at runtime, perhaps via an environment variable or a command-line argument to mpirun . On ARCHER, the magic incantation is: export MPICH_GNI_MAX_EAGER_MSG_SIZE=16382 which would mean that messages below 16K bytes are sent asynchronously (there will be a similar, but different, incantation on ARCHER2). The advice for tuning the performance of MPI_Send is find out what the distribution of message sizes for MPI_Send is (a profiling tool may be useful here); this applies to MPI_Isend as well: even in the non-blocking form, which can help to weaken synchronisation between sender and receiver, the amount of hand-shaking required is much reduced if the eager protocol is used; find out from the system documentation how to alter the value of the eager limit (there is no standardised way to set it); set the eager limit to a value larger than your typical message size -- you may need to add a small amount, say a few hundred bytes, to allow for any additional header information that is added to each message; measure the performance before and after to check that it has improved. Note It cannot be stressed strongly enough that although the performance may be affected by the value of the eager limit, the functionality of your program should be unaffected. If changing the eager limit affects the correctness of your program (e.g. whether or not it deadlocks) then you have an incorrect MPI program .","title":"Tuning performance"},{"location":"user-guide/tuning/#collective-operations","text":"Many of the collective operations that are commonly required by parallel scientific programs, i.e. operations that involve a group of processes, are already implemented in MPI. The canonical operation is perhaps adding up a double precision number across all MPI processes, which is best achieved by a reduction operation : MPI_Allreduce(&x, &xsum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD); This will be implemented using an efficient algorithm, for example based on a binary tree. Using such divide-and-conquer approaches typically results in an algorithm whose execution time on P processes scales as l o g 2 ( P ); compare this to a naive approach where every process sends its input to rank 0 where the time will scale as P . This might not be significant on your laptop, but even on as few as 1000 processes the tree-based algorithm will already be around 100 times faster. So, the basic advice is **always use a collective routine to implement your communications pattern** if at all possible. In real MPI applications, collective operations are often called on a small amount of data, for example a global reduction of a single variable. In these cases, the time taken will be dominated by message latency and the first port of call when looking at performance optimisation is to call them as infrequently as possible! If you are simply printing diagnostics to the screen in an iterative loop, consider doing this less frequently, e.g every ten iterations, or even not at all (although you should easily be able to turn diagnostics on again for future debugging). If you are computing some termination criterion, it may actually be faster overall to compute it and check for convergence infrequently, e.g. every ten iterations, even although this means that your program could run for up to 9 extra iterations. If possible, group data into a single buffer and call a single reduction with count > 1; two reductions with count = 1 will take almost exactly twice as long as a single reduction with count = 2. For example, if you only need to output a sequence of summed data at the end of the run, store the partial totals in an array and do a single reduction right at the end. Sometimes, the collective routines available may not appear to do exactly what you want. However, they can sometimes be used with a small amount of additional programming work: To operate on a subset of processes, create sub-communicators containing the relevant subset(s) and use these communicators instead of MPI_COMM_WORLD . Useful functions for communicator management include: MPI_Comm_split is the most general routine; MPI_Comm_split_type can be used to create a separate communicator for each shared-memory node with split type = MPI_COMM_TYPE_SHARED ; MPI_Cart_sub can divide a Cartesian communicator into regular slices. If the communication pattern is what you want, but the data on each process is not arranged in the required layout, consider using MPI derived data types for the input and/or output. This can be useful, for example, if you want to communicate non-contiguous data such as a subsection of a multidimensional array although care must be taken in defining these types to ensure they have the correct extents. Another example would be using MPI_Allreduce to add up an integer and a double-precision variable using a single call by putting them together into a C struct and defining a matching MPI datatype using MPI_Type_create_struct . Here you would also have to provide MPI with a custom reduction operation using MPI_Op_create . Many MPI programs call MPI_Barrier to explicitly synchronise all the processes. Although this can be useful for getting reliable performance timings, it is rare in practice to find a program where the call is actually needed for correctness. For example, you may see: // Ensure the input x is available on all processes MPI_Barrier(MPI_COMM_WORLD); // Perform a global reduction operation MPI_Allreduce(&x, &xsum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD); // Ensure the result xsum is available on all processes MPI_Barrier(MPI_COMM_WORLD); Neither of these barriers are needed as the reduction operation performs all the required synchronisation. If removing a barrier from your MPI code makes it run incorrectly, then this should ring alarm bells -- it is often a symptom of an underlying bug that is simply being masked by the barrier. For example, if you use non-blocking calls such as MPI_Irecv then it is the programmer's responsibility to ensure that these are completed at some later point, for example by calling MPI_Wait on the returned request object. A common bug is to forget to do this, in which case you might be reading the contents of the receive buffer before the incoming message has arrived (e.g. if the sender is running late). Calling a barrier may mask this bug as it will make all the processes wait for each other, perhaps allowing the late sender to catch up. However, this is not guaranteed so the real solution is to call the non-blocking communications correctly. One of the few times when a barrier may be required is if processes are communicating with each other via some other non-MPI method, e.g. via the file system. If you want processes to sequentially open, append to, then close the same file then barriers are a simple way to achieve this: for (i=0; i < size; i++) { if (rank == i) append_data_to_file(data, filename); MPI_Barrier(comm); } but this is really something of a special case. Global synchronisation may be required if you are using more advanced techniques such as hybrid MPI/OpenMP or single-sided MPI communication with put and get, but typically you should be using specialised routines such as MPI_Win_fence rather than MPI_Barrier . Note If you run a performance profiler on your code and it shows a lot of time being spent in a collective operation such as MPI_Allreduce , this is not necessarily a sign that the reduction operation itself is the bottleneck. This is often a symptom of load imbalance : even if a reduction operation is efficiently implemented, it may take a long time to complete if the MPI processes do not all call it at the same time. MPI_Allreduce synchronises across processes so will have to wait for all the processes to call it before it can complete. A single slow process will therefore adversely impact the performance of your entire parallel program.","title":"Collective operations"}]}